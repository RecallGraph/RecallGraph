<!DOCTYPE html>
<html lang="en">
<head><title>lib/operations/traverse/helpers</title></head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
<meta content="../../../" name="groc-relative-root">
<meta content="lib/operations/traverse/helpers" name="groc-document-path">
<meta content="lib/operations/traverse/helpers.js" name="groc-project-path">
<meta content="https://github.com/RecallGraph/RecallGraph" name="groc-github-url">
<link href="../../../assets/style.css" media="all" rel="stylesheet" type="text/css">
<script src="../../../assets/behavior.js" type="text/javascript"></script>
<body>
<div id="meta">
    <div class="file-path"><a
            href="https://github.com/RecallGraph/RecallGraph/blob/master/lib/operations/traverse/helpers.js">lib/operations/traverse/helpers.js</a>
    </div>
</div>
<div id="document">
    <div class="segment">
        <div class="code">
            <div class="wrapper"><span class="hljs-pi">'use strict'</span>

                <span class="hljs-keyword">const</span> { getComponentTagOption } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'../../helpers'</span>)
                <span class="hljs-keyword">const</span> { SERVICE_COLLECTIONS, SERVICE_GRAPHS } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'../../constants'</span>)
                <span class="hljs-keyword">const</span> { db, query } = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'@arangodb'</span>)
                <span class="hljs-keyword">const</span> { mapValues, remove, zipObject, map, cloneDeep, stubTrue, omit }
                = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
                <span class="hljs-keyword">const</span> show = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'../show'</span>)
                <span class="hljs-keyword">const</span> { utils: { attachSpan } } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'foxx-tracing'</span>)
                <span class="hljs-keyword">const</span> cytoscape = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'cytoscape'</span>)
                <span class="hljs-keyword">const</span> { parseExpr } = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'../helpers'</span>)

                <span class="hljs-keyword">const</span> skeletonVerticesColl =
                db._collection(SERVICE_COLLECTIONS.skeletonVertices)
                <span class="hljs-keyword">const</span> ends = {
                inbound: [<span class="hljs-string">'_from'</span>],
                outbound: [<span class="hljs-string">'_to'</span>],
                any: [<span class="hljs-string">'_from'</span>, <span class="hljs-string">'_to'</span>]
                }
                <span class="hljs-keyword">const</span> cto = getComponentTagOption(__filename)

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edgeIsValid</span> (<span
                        class="hljs-params">v, e, edgeCollections</span>) </span>{
                <span class="hljs-keyword">const</span> eColl = e.id().split(<span class="hljs-string">'/'</span>)[<span
                        class="hljs-number">0</span>]

                <span class="hljs-keyword">switch</span> (edgeCollections[eColl]) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'inbound'</span>:
                <span class="hljs-keyword">return</span> e.source().same(v)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'outbound'</span>:
                <span class="hljs-keyword">return</span> e.target().same(v)
                <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitIsValid</span> (<span
                        class="hljs-params">traversal, uniqueVertices, uniqueEdges, edgeCollections, v, e, currentPath</span>) </span>{
                <span class="hljs-keyword">let</span> visitIsValid = (e === <span class="hljs-literal">null</span>) ||
                edgeIsValid(v, e, edgeCollections)

                <span class="hljs-keyword">if</span> (visitIsValid) {
                <span class="hljs-keyword">switch</span> (uniqueVertices) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'global'</span>:
                visitIsValid = !traversal.gSet.has(v.id())
                <span class="hljs-keyword">break</span>

                <span class="hljs-keyword">case</span> <span class="hljs-string">'path'</span>:
                visitIsValid = !currentPath.vSet.has(v.id())
                <span class="hljs-keyword">break</span>
                }
                }

                <span class="hljs-keyword">if</span> (visitIsValid &amp;&amp; uniqueEdges === <span class="hljs-string">'path'</span>)
                {
                visitIsValid = (e === <span class="hljs-literal">null</span>) || !currentPath.eSet.has(e.id())
                }

                <span class="hljs-keyword">return</span> visitIsValid
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">addVisit</span> (<span class="hljs-params">traversal, minDepth, v, e, currentDepth, currentPath, vFilterFn, eFilterFn, pFilterFn</span>) </span>{
                <span class="hljs-keyword">const</span> path = cloneDeep(currentPath)
                <span class="hljs-keyword">const</span> vData = omit(v.data(), <span class="hljs-string">'id'</span>)

                traversal.gSet.add(v.id())
                path.vertices.push(vData)
                path.vSet.add(v.id())

                <span class="hljs-keyword">let</span> eData = <span class="hljs-literal">null</span>
                <span class="hljs-keyword">if</span> (e) {
                eData = omit(e.data(), <span class="hljs-string">'id'</span>, <span class="hljs-string">'source'</span>,
                <span class="hljs-string">'target'</span>)
                path.edges.push(eData)
                path.eSet.add(e.id())
                }

                <span class="hljs-keyword">if</span> (currentDepth &gt;= minDepth &amp;&amp; vFilterFn(vData) &amp;&amp;
                (!eData || eFilterFn(eData)) &amp;&amp; pFilterFn(path)) {
                traversal.vSet.add(v.id())
                traversal.paths.push(path)

                <span class="hljs-keyword">if</span> (e) {
                traversal.eSet.add(e.id())
                }
                }

                <span class="hljs-keyword">return</span> path
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNeighborhood</span> (<span
                        class="hljs-params">v</span>) </span>{
                <span class="hljs-keyword">return</span> v.neighborhood().reduce((acc, el) =&gt; {
                <span class="hljs-keyword">if</span> (!acc) {
                acc = {}
                }

                <span class="hljs-keyword">if</span> (el.isNode()) {
                acc[el.id()] = {
                vertex: el,
                edges: []
                }
                } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">const</span> groupNode = el.connectedNodes(<span class="hljs-string">`[id != '<span
                        class="hljs-subst">${v.id()}</span>']`</span>)
                acc[groupNode.id()].edges.push(el)
                }

                <span class="hljs-keyword">return</span> acc
                })
                }

                <span class="hljs-keyword">const</span> depthFirstWalk = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depthFirstWalk</span> (<span
                        class="hljs-params">traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
    eFilterFn, pFilterFn, v, e = null, currentDepth = 0,
    currentPath = { vertices: [], edges: [], vSet: new Set(</span>), <span class="hljs-title">eSet</span>: <span
                        class="hljs-title">new</span> <span class="hljs-title">Set</span>(<span
                        class="hljs-params"></span>) }) </span>{
                <span class="hljs-keyword">if</span> (visitIsValid(traversal, uniqueVertices, uniqueEdges,
                edgeCollections, v, e, currentPath)) {
                <span class="hljs-keyword">const</span> path = addVisit(traversal, minDepth, v, e, currentDepth,
                currentPath, vFilterFn, eFilterFn, pFilterFn)

                <span class="hljs-keyword">if</span> (currentDepth &lt; maxDepth) {
                <span class="hljs-keyword">const</span> nbd = getNeighborhood(v)

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span
                        class="hljs-keyword">in</span> nbd) {
                <span class="hljs-keyword">const</span> group = nbd[key]
                <span class="hljs-keyword">const</span> nv = group.vertex

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ne <span
                        class="hljs-keyword">of</span> group.edges) {
                depthFirstWalk(traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
                eFilterFn, pFilterFn, nv, ne, currentDepth + <span class="hljs-number">1</span>, path)
                }
                }
                }
                }
                }, <span class="hljs-string">'depthFirstWalk'</span>, cto)

                <span class="hljs-keyword">const</span> breadthFirstWalk = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">breadthFirstWalk</span> (<span
                        class="hljs-params">traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
    eFilterFn, pFilterFn, nbds, currentDepth = 0</span>) </span>{
                <span class="hljs-keyword">const</span> childNbds = []

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> nbd <span
                        class="hljs-keyword">of</span> nbds) {
                <span class="hljs-keyword">const</span> { groups, path: currentPath } = nbd

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span
                        class="hljs-keyword">in</span> groups) {
                <span class="hljs-keyword">const</span> group = groups[key]
                <span class="hljs-keyword">const</span> v = group.vertex

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> e <span
                        class="hljs-keyword">of</span> group.edges) {
                <span class="hljs-keyword">if</span> (visitIsValid(traversal, uniqueVertices, uniqueEdges,
                edgeCollections, v, e, currentPath)) {
                <span class="hljs-keyword">const</span> path = addVisit(traversal, minDepth, v, e, currentDepth,
                currentPath, vFilterFn, eFilterFn, pFilterFn)

                <span class="hljs-keyword">if</span> (currentDepth &lt; maxDepth) {
                childNbds.push({
                path,
                groups: getNeighborhood(v)
                })
                }
                }
                }
                }
                }

                <span class="hljs-keyword">if</span> (currentDepth &lt; maxDepth) {
                breadthFirstWalk(traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
                eFilterFn,
                pFilterFn, childNbds, currentDepth + <span class="hljs-number">1</span>)
                }
                }, <span class="hljs-string">'breadthFirstWalk'</span>, cto)
            </div>
        </div>
    </div>
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>Public</p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-function"><span class="hljs-keyword">function</span> <span
                    class="hljs-title">getEnds</span> (<span class="hljs-params">direction</span>) </span>{
                <span class="hljs-keyword">return</span> ends[direction.toLowerCase()]
                }

                <span class="hljs-keyword">const</span> traverseSkeletonGraph = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseSkeletonGraph</span> (<span
                        class="hljs-params">timestamp, svid, maxDepth, edgeCollections, bfs, uniqueVertices</span>) </span>{
                <span class="hljs-keyword">const</span> sv = skeletonVerticesColl.firstExample(<span
                        class="hljs-string">'meta.id'</span>, svid)
                <span class="hljs-keyword">const</span> svl = sv &amp;&amp; sv.validity
                <span class="hljs-keyword">const</span> svv = svl &amp;&amp; svl.some(vo =&gt; vo.valid_since &lt;=
                timestamp &amp;&amp; vo.valid_until &gt; timestamp)

                <span class="hljs-keyword">if</span> (svv) {
                maxDepth *= <span class="hljs-number">2</span>
                <span class="hljs-keyword">if</span> (uniqueVertices === <span class="hljs-string">'none'</span>) {
                uniqueVertices = <span class="hljs-string">'path'</span>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (uniqueVertices === <span
                        class="hljs-string">'global'</span>) {
                bfs = <span class="hljs-literal">true</span>
                }

                <span class="hljs-keyword">const</span> ecs = mapValues(edgeCollections, getEnds)

                <span class="hljs-keyword">return</span> query<span class="hljs-string">`
        let ecs = <span class="hljs-subst">${ecs}</span>
        let eca = attributes(ecs)
        
        for v, e, p in 0..<span class="hljs-subst">${maxDepth}</span>
        any <span class="hljs-subst">${sv._id}</span>
        graph <span class="hljs-subst">${SERVICE_GRAPHS.skeleton}</span>
        
        prune v == null ||
          !length(v.validity[* filter CURRENT.valid_since &lt;= <span class="hljs-subst">${timestamp}</span> &amp;&amp; CURRENT.valid_until &gt; <span
                            class="hljs-subst">${timestamp}</span>]) ||
          e != null &amp;&amp;
          !length(e.validity[* filter CURRENT.valid_since &lt;= <span class="hljs-subst">${timestamp}</span> &amp;&amp; CURRENT.valid_until &gt; <span
                            class="hljs-subst">${timestamp}</span>]) ||
          is_same_collection(<span class="hljs-subst">${SERVICE_COLLECTIONS.skeletonEdgeHubs}</span>, v) &amp;&amp;
          (v.collection not in eca || ((v._id == e._from) ? '_from' : '_to') not in ecs[v.collection])
          
        options { bfs: <span class="hljs-subst">${bfs}</span>, uniqueVertices: <span class="hljs-subst">${uniqueVertices}</span> }
          
        filter v != null &amp;&amp;
          length(v.validity[* filter CURRENT.valid_since &lt;= <span class="hljs-subst">${timestamp}</span> &amp;&amp; CURRENT.valid_until &gt; <span
                            class="hljs-subst">${timestamp}</span>])
        filter e == null ||
          length(e.validity[* filter CURRENT.valid_since &lt;= <span class="hljs-subst">${timestamp}</span> &amp;&amp; CURRENT.valid_until &gt; <span
                            class="hljs-subst">${timestamp}</span>])
        filter length(p.edges) % 2 == 0
        
        let seh = p.vertices[-2]
        let oc = seh &amp;&amp; seh.collection
        let dKey = e &amp;&amp; (v._id == e._from) ? '_from' : '_to'
        filter e == null || oc in eca &amp;&amp; dKey in ecs[oc]
        
        collect aggregate vertices = unique(v.meta.id), edges = unique(seh.meta.id)
        
        return {vertices, edges: edges[* filter CURRENT != null]}
      `</span>.toArray()[<span class="hljs-number">0</span>]
                } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> {
                vertices: [],
                edges: []
                }
                }
                }, <span class="hljs-string">'traverseSkeletonGraph'</span>, cto)

                <span class="hljs-keyword">const</span> buildFilteredGraph = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildFilteredGraph</span> (<span
                        class="hljs-params">svid, vertices, edges, minDepth, maxDepth, bfs, uniqueVertices, uniqueEdges,
    edgeCollections, vFilter, eFilter, pFilter</span>) </span>{
                <span class="hljs-keyword">const</span> cy = cytoscape()

                cy.startBatch()

                cy.add(vertices.map(v =&gt; ({
                group: <span class="hljs-string">'nodes'</span>,
                data: <span class="hljs-built_in">Object</span>.assign({
                id: v._id
                }, v)
                })))

                cy.add(edges.map(e =&gt; ({
                group: <span class="hljs-string">'edges'</span>,
                data: <span class="hljs-built_in">Object</span>.assign({
                id: e._id,
                source: e._from,
                target: e._to
                }, e)
                })))

                cy.endBatch()

                <span class="hljs-keyword">const</span> vMap = zipObject(map(vertices, <span
                        class="hljs-string">'_id'</span>), vertices)
                <span class="hljs-keyword">const</span> eMap = zipObject(map(edges, <span
                        class="hljs-string">'_id'</span>), edges)
                <span class="hljs-keyword">const</span> traversal = {
                gSet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
                vSet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
                eSet: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
                paths: []
                }
                <span class="hljs-keyword">const</span> sv = cy.$id(svid)
                <span class="hljs-keyword">const</span> vFilterFn = vFilter ? parseExpr(vFilter) : stubTrue
                <span class="hljs-keyword">const</span> eFilterFn = eFilter ? parseExpr(eFilter) : stubTrue
                <span class="hljs-keyword">const</span> pFilterFn = pFilter ? parseExpr(pFilter) : stubTrue

                <span class="hljs-keyword">if</span> (uniqueVertices === <span class="hljs-string">'global'</span>) {
                bfs = <span class="hljs-literal">true</span>
                }

                <span class="hljs-keyword">if</span> (bfs) {
                breadthFirstWalk(traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
                eFilterFn,
                pFilterFn, [
                {
                path: { vertices: [], edges: [], vSet: <span class="hljs-keyword">new</span> <span
                        class="hljs-built_in">Set</span>(), eSet: <span class="hljs-keyword">new</span> <span
                        class="hljs-built_in">Set</span>() },
                groups: {
                [sv.id()]: {
                vertex: sv,
                edges: [<span class="hljs-literal">null</span>]
                }
                }
                }
                ])
                } <span class="hljs-keyword">else</span> {
                depthFirstWalk(traversal, minDepth, maxDepth, uniqueVertices, uniqueEdges, edgeCollections, vFilterFn,
                eFilterFn,
                pFilterFn, sv)
                }

                traversal.vertices = <span class="hljs-built_in">Array</span>.from(traversal.vSet).map(id =&gt;
                vMap[id])
                traversal.edges = <span class="hljs-built_in">Array</span>.from(traversal.eSet).map(id =&gt; eMap[id])

                <span class="hljs-keyword">delete</span> traversal.gSet
                <span class="hljs-keyword">delete</span> traversal.vSet
                <span class="hljs-keyword">delete</span> traversal.eSet
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> path <span
                        class="hljs-keyword">of</span> traversal.paths) {
                <span class="hljs-keyword">delete</span> path.vSet
                <span class="hljs-keyword">delete</span> path.eSet
                }

                <span class="hljs-keyword">return</span> traversal
                }, <span class="hljs-string">'buildFilteredGraph'</span>, cto)

                <span class="hljs-keyword">const</span> buildNodeIdGroupsByType = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildNodeIdGroupsByType</span> (<span
                        class="hljs-params">typeGroups, types = { vertices: [], edges: [] }</span>) </span>{
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> type <span
                        class="hljs-keyword">in</span> types) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span
                        class="hljs-keyword">of</span> typeGroups[type]) {
                <span class="hljs-keyword">const</span> [coll, key] = id.split(<span class="hljs-string">'/'</span>)

                <span class="hljs-keyword">let</span> group = types[type].find(group =&gt; group.coll === coll)
                <span class="hljs-keyword">if</span> (!group) {
                group = { coll, keys: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>() }
                types[type].push(group)
                }

                group.keys.add(key)
                }
                }

                <span class="hljs-keyword">return</span> types
                }, <span class="hljs-string">'buildNodeIdGroupsByType'</span>, cto)

                <span class="hljs-keyword">const</span> buildNodeGroupsByType = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildNodeGroupsByType</span> (<span
                        class="hljs-params">timestamp, types, vFilter, eFilter</span>) </span>{
                <span class="hljs-keyword">const</span> built = {
                vertices: [],
                edges: []
                }
                <span class="hljs-keyword">if</span> (types.vertices.length) {
                <span class="hljs-keyword">const</span> vPath = createNodeBracepath(types.vertices)
                built.vertices = show(vPath, timestamp, { postFilter: vFilter })

                <span class="hljs-keyword">if</span> (types.edges.length) {
                <span class="hljs-keyword">const</span> ePath = createNodeBracepath(types.edges)
                built.edges = show(ePath, timestamp, { postFilter: eFilter })
                }

                removeFreeEdges(built.vertices, built.edges)
                }

                <span class="hljs-keyword">return</span> built
                }, <span class="hljs-string">'buildNodeGroupsByType'</span>, cto)

                <span class="hljs-keyword">const</span> createNodeBracepath = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNodeBracepath</span> (<span
                        class="hljs-params">nodeGroups</span>) </span>{
                <span class="hljs-keyword">const</span> pathSegments = nodeGroups.map(group =&gt; {
                <span class="hljs-keyword">let</span> pathSegment = <span class="hljs-string">`<span class="hljs-subst">${group.coll}</span>/`</span>

                <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Array</span>.isArray(group.keys)
                ? group.keys : <span class="hljs-built_in">Array</span>.from(group.keys)
                <span class="hljs-keyword">if</span> (keys.length &gt; <span class="hljs-number">1</span>) {
                pathSegment += <span class="hljs-string">`{<span class="hljs-subst">${keys.join(',')}</span>}`</span>
                } <span class="hljs-keyword">else</span> {
                pathSegment += keys[<span class="hljs-number">0</span>]
                }

                <span class="hljs-keyword">return</span> pathSegment
                })

                <span class="hljs-keyword">let</span> path = <span class="hljs-string">'/n/'</span>

                <span class="hljs-keyword">if</span> (pathSegments.length &gt; <span class="hljs-number">1</span>) {
                path += <span class="hljs-string">`{<span class="hljs-subst">${pathSegments.join(',')}</span>}`</span>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathSegments.length ===
                <span class="hljs-number">1</span>) {
                path += pathSegments[<span class="hljs-number">0</span>]
                }

                <span class="hljs-keyword">return</span> path
                }, <span class="hljs-string">'createNodeBracepath'</span>, cto)

                <span class="hljs-keyword">const</span> removeFreeEdges = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">removeFreeEdges</span> (<span
                        class="hljs-params">vertices, edges</span>) </span>{
                <span class="hljs-keyword">const</span> vSet = <span class="hljs-keyword">new</span> <span
                        class="hljs-built_in">Set</span>(map(vertices, <span class="hljs-string">'_id'</span>))

                remove(edges, e =&gt; [e._from, e._to].some(vid =&gt; !vSet.has(vid)))
                }, <span class="hljs-string">'removeFreeEdges'</span>, cto)

                <span class="hljs-built_in">module</span>.exports = {
                getEnds,
                traverseSkeletonGraph,
                buildFilteredGraph,
                buildNodeIdGroupsByType,
                buildNodeGroupsByType,
                createNodeBracepath,
                removeFreeEdges
                }
            </div>
        </div>
    </div>
</div>
</body>
</html>