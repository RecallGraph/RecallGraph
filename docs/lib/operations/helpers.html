<!DOCTYPE html>
<html lang="en">
<head><title>lib/operations/helpers</title></head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
<meta content="../../" name="groc-relative-root">
<meta content="lib/operations/helpers" name="groc-document-path">
<meta content="lib/operations/helpers.js" name="groc-project-path">
<meta content="https://github.com/RecallGraph/RecallGraph" name="groc-github-url">
<link href="../../assets/style.css" media="all" rel="stylesheet" type="text/css">
<script src="../../assets/behavior.js" type="text/javascript"></script>
<body>
<div id="meta">
    <div class="file-path"><a href="https://github.com/RecallGraph/RecallGraph/blob/master/lib/operations/helpers.js">lib/operations/helpers.js</a>
    </div>
</div>
<div id="document">
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>eslint eqeqeq:0 </p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-pi">'use strict'</span>

                <span class="hljs-keyword">const</span> {
                difference, values, chain, concat, find, isString, stubFalse, negate, identity, isFunction, memoize
                } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
                <span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'lodash'</span>)
                <span class="hljs-keyword">const</span> minimatch = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'minimatch'</span>)
                <span class="hljs-keyword">const</span> expand = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'brace-expansion'</span>)
                <span class="hljs-keyword">const</span> gg = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'@arangodb/general-graph'</span>)
                <span class="hljs-keyword">const</span> { getCollectionType, getComponentTagOption } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers'</span>)
                <span class="hljs-keyword">const</span> {
                SERVICE_GRAPHS, SERVICE_COLLECTIONS, TRANSIENT_EVENT_SUPERNODE, COLL_TYPES_REF, SORT_TYPES
                } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../constants'</span>)
                <span class="hljs-keyword">const</span> { aql, db } = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'@arangodb'</span>)
                <span class="hljs-keyword">const</span> jsep = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'jsep'</span>)
                <span class="hljs-keyword">const</span> { utils: { attachSpan } } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'foxx-tracing'</span>)

                <span class="hljs-keyword">const</span> commandColl = db._collection(SERVICE_COLLECTIONS.commands)
                <span class="hljs-keyword">const</span> cto = getComponentTagOption(__filename)

                <span class="hljs-keyword">const</span> OP_MAP = <span class="hljs-built_in">Object</span>.freeze({
                <span class="hljs-string">'typeof'</span>: (val) =&gt; <span class="hljs-keyword">typeof</span> val,
                glob: (str, pattern) =&gt; isString(pattern) &amp;&amp; isString(str) &amp;&amp; minimatch(str,
                pattern),
                regx: (str, pattern) =&gt; {
                <span class="hljs-keyword">if</span> (isString(pattern) &amp;&amp; isString(str)) {
                <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> regex = getRegExp(pattern)

                <span class="hljs-keyword">return</span> regex.test(str)
                } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-built_in">console</span>.error(e.stack)
                }
                }

                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
                }
                })
                exports.OP_MAP = OP_MAP

                jsep.addBinaryOp(<span class="hljs-string">'=~'</span>, <span class="hljs-number">6</span>)
                jsep.addBinaryOp(<span class="hljs-string">'=*'</span>, <span class="hljs-number">6</span>)
                jsep.addBinaryOp(<span class="hljs-string">'in'</span>, <span class="hljs-number">6</span>)
                jsep.addBinaryOp(<span class="hljs-string">'**'</span>, <span class="hljs-number">4</span>)
                jsep.addLiteral(<span class="hljs-string">'$Math'</span>, <span class="hljs-built_in">Math</span>)
                jsep.addLiteral(<span class="hljs-string">'$_'</span>, _)
                jsep.addLiteral(<span class="hljs-string">'$RG'</span>, OP_MAP)

                <span class="hljs-keyword">const</span> getAST = jsep
                exports.getAST = getAST

                <span class="hljs-keyword">const</span> getRegExp = memoize(pattern =&gt; <span
                        class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern))

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParseTree</span> (<span
                        class="hljs-params">ast</span>) </span>{
                <span class="hljs-keyword">switch</span> (ast.type) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; node[ast.name]
                <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
                <span class="hljs-keyword">return</span> () =&gt; ast.value
                <span class="hljs-keyword">case</span> <span class="hljs-string">'MemberExpression'</span>:
                <span class="hljs-keyword">const</span> memberFn = (node) =&gt; (getParseTree(ast.object)(node) || {})
                <span class="hljs-keyword">const</span> propertyFn = getParseTree(ast.property)

                <span class="hljs-keyword">return</span> ast.computed ? (node) =&gt; memberFn(node)[propertyFn(node)] :
                (node) =&gt; propertyFn(memberFn(node))
                <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrayExpression'</span>:
                <span class="hljs-keyword">const</span> fnArr = ast.elements.map(getParseTree)

                <span class="hljs-keyword">return</span> (node) =&gt; fnArr.map(fn =&gt; fn(node))
                <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
                <span class="hljs-keyword">const</span> argFns = ast.arguments.map(getParseTree)

                <span class="hljs-keyword">let</span> callee
                <span class="hljs-keyword">let</span> thisRef = _
                <span class="hljs-keyword">switch</span> (ast.callee.type) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
                callee = getParseTree(ast.callee)
                <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> <span class="hljs-string">'MemberExpression'</span>:
                callee = getParseTree(ast.callee)
                thisRef = ast.callee.object.value
                <span class="hljs-keyword">break</span>
                <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
                callee = getParseTree(ast.callee.callee)
                }

                <span class="hljs-keyword">return</span> (node) =&gt; {
                <span class="hljs-keyword">const</span> thisObj = thisRef || node
                <span class="hljs-keyword">let</span> resolved
                <span class="hljs-keyword">if</span> (ast.callee.type === <span
                        class="hljs-string">'CallExpression'</span>) {
                <span class="hljs-keyword">const</span> callArgs = ast[<span class="hljs-string">'callee'</span>].arguments.map(getParseTree)

                resolved = callee(thisObj)
                .apply(thisObj, callArgs.map(fn =&gt; fn(node)))
                } <span class="hljs-keyword">else</span> {
                resolved = callee(thisObj)
                }

                <span class="hljs-keyword">const</span> args = argFns.map(fn =&gt; fn(node))
                <span class="hljs-keyword">const</span> thisBinding = (thisObj === node) &amp;&amp; ast.callee.object ?
                getParseTree(ast.callee.object)(node) : thisObj

                <span class="hljs-keyword">return</span> isFunction(resolved) ? resolved.apply(thisBinding, args) :
                <span class="hljs-literal">false</span>
                }

                <span class="hljs-keyword">case</span> <span class="hljs-string">'LogicalExpression'</span>:
                <span class="hljs-keyword">case</span> <span class="hljs-string">'BinaryExpression'</span>:
                <span class="hljs-keyword">const</span> left = getParseTree(ast.left)
                <span class="hljs-keyword">const</span> right = getParseTree(ast.right)

                <span class="hljs-keyword">switch</span> (ast.operator) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'=='</span>:
            </div>
        </div>
    </div>
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>noinspection EqualityComparisonWithCoercionJS</p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-keyword">return</span> (node) =&gt; left(node) == right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'==='</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) === right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'!='</span>:
            </div>
        </div>
    </div>
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>noinspection EqualityComparisonWithCoercionJS</p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-keyword">return</span> (node) =&gt; left(node) != right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'!=='</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) !== right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;='</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt;= right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;='</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;= right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'in'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; {
                <span class="hljs-keyword">const</span> resolvedRight = right(node)

                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(resolvedRight)
                &amp;&amp; left(node) <span class="hljs-keyword">in</span> resolvedRight
                }
                <span class="hljs-keyword">case</span> <span class="hljs-string">'=~'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; OP_MAP.regx(left(node), right(node))
                <span class="hljs-keyword">case</span> <span class="hljs-string">'=*'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; OP_MAP.glob(left(node), right(node))
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;&amp;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &amp;&amp; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'||'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) || right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) ^ right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'|'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) | right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &amp; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt;&lt; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;&gt; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;&gt;'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;&gt;&gt; right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) + right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) - right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) * right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) / right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) % right(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'**'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; left(node) ** right(node)
                <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> stubFalse
                }
                <span class="hljs-keyword">case</span> <span class="hljs-string">'UnaryExpression'</span>:
                <span class="hljs-keyword">const</span> argEval = getParseTree(ast.argument)

                <span class="hljs-keyword">switch</span> (ast.operator) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'!'</span>:
                <span class="hljs-keyword">return</span> negate(argEval)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; -argEval(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'~'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; ~argEval(node)
                <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
                <span class="hljs-keyword">return</span> (node) =&gt; +argEval(node)

                <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">return</span> stubFalse
                }
                <span class="hljs-keyword">case</span> <span class="hljs-string">'ThisExpression'</span>:
                <span class="hljs-keyword">return</span> identity
                <span class="hljs-keyword">case</span> <span class="hljs-string">'ConditionalExpression'</span>:
                <span class="hljs-keyword">const</span> test = getParseTree(ast.test)
                <span class="hljs-keyword">const</span> consequent = getParseTree(ast.consequent)
                <span class="hljs-keyword">const</span> alternate = getParseTree(ast.alternate)

                <span class="hljs-keyword">return</span> (node) =&gt; test(node) ? consequent(node) : alternate(node)
                }
                }

                exports.parseExpr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">parseExpr</span> (<span class="hljs-params">expr</span>) </span>{
                <span class="hljs-keyword">const</span> ast = getAST(expr)

                <span class="hljs-keyword">return</span> getParseTree(ast)
                }

                exports.filter = attachSpan(<span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">filter</span> (<span class="hljs-params">nodes, filterExpr</span>) </span>{
                <span class="hljs-keyword">const</span> ast = getAST(filterExpr)
                <span class="hljs-keyword">const</span> filterFn = getParseTree(ast)

                <span class="hljs-keyword">return</span> nodes.filter(filterFn)
                }, <span class="hljs-string">'filter'</span>, cto)

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMatchingCollNames</span> (<span
                        class="hljs-params">graphNames</span>) </span>{
                <span class="hljs-keyword">return</span> chain(graphNames)
                .map(gg._graph)
                .map(graph =&gt; concat(graph._vertexCollections(), graph._edgeCollections()))
                .flatten()
                .invokeMap(<span class="hljs-string">'name'</span>)
                .uniq()
                .value()
                }

                exports.getMatchingCollNames = getMatchingCollNames

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonServiceCollections</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> difference(
                db._collections()
                .map(coll =&gt; coll.name())
                .filter(collName =&gt; !collName.startsWith(<span class="hljs-string">'_'</span>)),
                values(SERVICE_COLLECTIONS)
                )
                }

                exports.getNonServiceCollections = getNonServiceCollections

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeAndSearchPatternFor</span> (<span
                        class="hljs-params">path</span>) </span>{
                <span class="hljs-keyword">const</span> collections = getNonServiceCollections()
                <span class="hljs-keyword">const</span> scopes = getAvailableScopes(collections)

                <span class="hljs-keyword">const</span> scope = find(scopes, scope =&gt; minimatch(path,
                scope.pathPattern))
                <span class="hljs-keyword">const</span> searchPattern = scope.prefix ?
                path.substring(scope.prefix.length) : path

                <span class="hljs-keyword">return</span> { scope, searchPattern }
                }

                exports.getScopeAndSearchPatternFor = getScopeAndSearchPatternFor

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollTypes</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">const</span> collTypes = {}
                <span class="hljs-keyword">const</span> nonServiceCollections = getNonServiceCollections()

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> coll <span
                        class="hljs-keyword">of</span> nonServiceCollections) {
                collTypes[coll] = COLL_TYPES_REF[getCollectionType(coll)]
                }

                <span class="hljs-keyword">return</span> collTypes
                }

                exports.getCollTypes = getCollTypes

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollTypeInitializer</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">const</span> collTypes = getCollTypes()

                <span class="hljs-keyword">return</span> aql<span class="hljs-string">`let collTypes = <span
                        class="hljs-subst">${collTypes}</span>`</span>
                }

                exports.getCollTypeInitializer = getCollTypeInitializer

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeInitializers</span> (<span
                        class="hljs-params">scope, searchPattern</span>) </span>{
                <span class="hljs-keyword">return</span> scope.initializers ? scope.initializers(searchPattern) :
                aql.literal(<span class="hljs-string">''</span>)
                }

                exports.getScopeInitializers = getScopeInitializers

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventLogQueryPrefix</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> aql<span class="hljs-string">`
    for v, e, p in 2..<span class="hljs-subst">${Number.MAX_SAFE_INTEGER}</span>
    outbound <span class="hljs-subst">${TRANSIENT_EVENT_SUPERNODE._id}</span>
    <span class="hljs-subst">${commandColl}</span>
  `</span>
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeFilters</span> (<span
                        class="hljs-params">scope, searchPattern</span>) </span>{
                <span class="hljs-keyword">return</span> scope.filters ? scope.filters(searchPattern) : {
                filter: aql.literal(<span class="hljs-string">''</span>),
                prune: aql.literal(<span class="hljs-string">'false'</span>)
                }
                }

                exports.getScopeFilters = getScopeFilters

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTimeBoundFilters</span> (<span
                        class="hljs-params">since, until</span>) </span>{
                <span class="hljs-keyword">const</span> filters = []
                <span class="hljs-keyword">let</span> prune = aql.literal(<span class="hljs-string">'false'</span>)

                <span class="hljs-keyword">if</span> (since) {
                filters.push(aql<span class="hljs-string">`filter v.ctime &gt;= <span class="hljs-subst">${since}</span>`</span>)
                }
                <span class="hljs-keyword">if</span> (until) {
                prune = aql<span class="hljs-string">`v.ctime &gt;= <span class="hljs-subst">${until}</span>`</span>
                filters.push(aql<span class="hljs-string">`filter v.ctime &lt; <span class="hljs-subst">${until}</span>`</span>)
                }

                <span class="hljs-keyword">return</span> { prune, filters }
                }

                exports.getTimeBoundFilters = getTimeBoundFilters

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDBScope</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/'</span>
                }
                }

                exports.getDBScope = getDBScope

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGraphScope</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/g/*'</span>,
                prefix: <span class="hljs-string">'/g/'</span>,
                filters: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> graphNames = difference(gg._list(), values(SERVICE_GRAPHS))
                <span class="hljs-keyword">const</span> matches = minimatch.match(graphNames, searchPattern)
                <span class="hljs-keyword">const</span> collNames = getMatchingCollNames(matches)

                <span class="hljs-keyword">return</span> {
                filter: aql<span class="hljs-string">`filter p.vertices[1]['collection'] in <span class="hljs-subst">${collNames}</span>`</span>,
                prune: aql<span class="hljs-string">`length(p.edges) == 1 &amp;&amp; v['collection'] not in <span
                        class="hljs-subst">${collNames}</span>`</span>
                }
                }
                }
                }

                exports.getGraphScope = getGraphScope

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollectionScope</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/c/*'</span>,
                prefix: <span class="hljs-string">'/c/'</span>,
                filters: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> matches = minimatch.match(collections, searchPattern)

                <span class="hljs-keyword">return</span> {
                filter: aql<span class="hljs-string">`filter p.vertices[1]['collection'] in <span class="hljs-subst">${matches}</span>`</span>,
                prune: aql<span class="hljs-string">`length(p.edges) == 1 &amp;&amp; v['collection'] not in <span
                        class="hljs-subst">${matches}</span>`</span>
                }
                }
                }
                }

                exports.getCollectionScope = getCollectionScope

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeGlobScope</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/ng/**'</span>,
                prefix: <span class="hljs-string">'/ng/'</span>,
                filters: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> idPattern = minimatch.makeRe(searchPattern).source

                <span class="hljs-keyword">return</span> {
                filter: aql<span class="hljs-string">`filter p.vertices[2].meta.id =~ <span class="hljs-subst">${idPattern}</span>`</span>,
                prune: aql<span class="hljs-string">`length(p.edges) == 2 &amp;&amp; v.meta.id !~ <span
                        class="hljs-subst">${idPattern}</span>`</span>
                }
                }
                }
                }

                exports.getNodeGlobScope = getNodeGlobScope

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeBraceScope</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/n/**'</span>,
                prefix: <span class="hljs-string">'/n/'</span>,
                filters: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> collMatches = chain(expand(searchPattern))
                .map(pattern =&gt; pattern.split(<span class="hljs-string">'/'</span>)[<span
                        class="hljs-number">0</span>])
                .intersection(collections)
                .value()

                <span class="hljs-keyword">return</span> {
                filter: aql<span class="hljs-string">`
            let collName = p.vertices[1]['collection']
            filter collName in <span class="hljs-subst">${collMatches}</span>
            filter p.edges[1].meta.id in idGroups[collName]
          `</span>, <span class="hljs-comment">// See initializers below for idGroups definition.</span>
                prune: aql<span class="hljs-string">`
            length(p.edges) == 2 &amp;&amp; (p.vertices[1]['collection'] not in <span
                            class="hljs-subst">${collMatches}</span>
              || p.edges[1].meta.id not in idGroups[p.vertices[1]['collection']])
          `</span>
                }
                },
                initializers: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> idMatchesWrapper = chain(expand(searchPattern))
                <span class="hljs-keyword">const</span> collMatches = idMatchesWrapper
                .map(pattern =&gt; pattern.split(<span class="hljs-string">'/'</span>)[<span
                        class="hljs-number">0</span>])
                .intersection(collections)
                .value()
                <span class="hljs-keyword">const</span> idGroups = idMatchesWrapper
                .map(match =&gt; match.split(<span class="hljs-string">'/'</span>))
                .filter(matchPair =&gt; collMatches.includes(matchPair[<span class="hljs-number">0</span>]))
                .transform((groups, matchPair) =&gt; {
                <span class="hljs-keyword">const</span> group = matchPair[<span class="hljs-number">0</span>]
                groups[group] = groups[group] || []
                groups[group].push(matchPair.join(<span class="hljs-string">'/'</span>))
                }, {})
                .value()

                <span class="hljs-keyword">return</span> aql<span class="hljs-string">`let idGroups = <span
                        class="hljs-subst">${idGroups}</span>`</span>
                }
                }
                }

                exports.getNodeBraceScope = getNodeBraceScope

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAvailableScopes</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                database: getDBScope(),
                graph: getGraphScope(),
                collection: getCollectionScope(collections),
                nodeGlob: getNodeGlobScope(),
                nodeExact: getNodeBraceScope(collections)
                }
                }

                exports.getLimitClause = <span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">getLimitClause</span> (<span class="hljs-params">limit, skip</span>) </span>{
                <span class="hljs-keyword">if</span> (limit) {
                <span class="hljs-keyword">if</span> (skip) {
                <span class="hljs-keyword">return</span> aql<span class="hljs-string">`limit <span class="hljs-subst">${skip}</span>, <span
                        class="hljs-subst">${limit}</span>`</span>
                } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> aql<span class="hljs-string">`limit <span class="hljs-subst">${limit}</span>`</span>
                }
                }

                <span class="hljs-keyword">return</span> aql.literal(<span class="hljs-string">''</span>)
                }

                exports.getEventLogQueryInitializer = <span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">getEventLogQueryInitializer</span> (<span
                        class="hljs-params">path, since, until</span>) </span>{
                <span class="hljs-keyword">const</span> { scope, searchPattern } = getScopeAndSearchPatternFor(path)
                <span class="hljs-keyword">const</span> scopeFilters = getScopeFilters(scope, searchPattern)
                <span class="hljs-keyword">const</span> timeBoundFilters = getTimeBoundFilters(since, until)
                <span class="hljs-keyword">const</span> pruneFilters = aql.join([scopeFilters.prune,
                timeBoundFilters.prune], <span class="hljs-string">' || '</span>)
                <span class="hljs-keyword">const</span> pruneClause = aql.join([aql.literal(<span class="hljs-string">'prune'</span>),
                pruneFilters], <span class="hljs-string">' '</span>)

                <span class="hljs-keyword">const</span> queryParts = [
                getCollTypeInitializer(),
                getScopeInitializers(scope, searchPattern),
                getEventLogQueryPrefix(),
                pruneClause,
                scopeFilters.filter
                ]

                timeBoundFilters.filters.forEach(filter =&gt; queryParts.push(filter))

                <span class="hljs-keyword">return</span> queryParts
                }

                exports.getSort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">getSort</span> (<span class="hljs-params">sortKey</span>) </span>{
                <span class="hljs-keyword">return</span> SORT_TYPES[sortKey.toUpperCase()]
                }
            </div>
        </div>
    </div>
</div>
</body>
</html>