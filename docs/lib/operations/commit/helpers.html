<!DOCTYPE html>
<html lang="en">
<head><title>lib/operations/commit/helpers</title></head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
<meta content="../../../" name="groc-relative-root">
<meta content="lib/operations/commit/helpers" name="groc-document-path">
<meta content="lib/operations/commit/helpers.js" name="groc-project-path">
<meta content="https://github.com/RecallGraph/RecallGraph" name="groc-github-url">
<link href="../../../assets/style.css" media="all" rel="stylesheet" type="text/css">
<script src="../../../assets/behavior.js" type="text/javascript"></script>
<body>
<div id="meta">
    <div class="file-path"><a
            href="https://github.com/RecallGraph/RecallGraph/blob/master/lib/operations/commit/helpers.js">lib/operations/commit/helpers.js</a>
    </div>
</div>
<div id="document">
    <div class="segment">
        <div class="code">
            <div class="wrapper"><span class="hljs-pi">'use strict'</span>

                <span class="hljs-keyword">const</span> { snapshotInterval, getCollectionType, getComponentTagOption } =
                <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../helpers'</span>)
                <span class="hljs-keyword">const</span> {
                SERVICE_COLLECTIONS, TRANSIENT_EVENT_SUPERNODE, SERVICE_GRAPHS,
                COLLECTION_TYPES: { VERTEX, EDGE },
                SYNC_TYPES: { DELETED: SYNC_DELETED, EXISTING },
                DB_OPS: { INSERT, UPDATE, REMOVE, REPLACE, RESTORE },
                EVENTS: { DELETED, COLL_INIT, CREATED, RESTORED, UPDATED }
                } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../constants'</span>)
                <span class="hljs-keyword">const</span> { getNonServiceCollections, getMatchingCollNames } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers'</span>)
                <span class="hljs-keyword">const</span> {
                merge, cloneDeep, pick, memoize, mapKeys, intersection, noop, filter, last, difference, values, chain,
                find
                } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
                <span class="hljs-keyword">const</span> jiff = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'jiff'</span>)
                <span class="hljs-keyword">const</span> { db, time: dbtime, errors: ARANGO_ERRORS, query, aql } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'@arangodb'</span>)
                <span class="hljs-keyword">const</span> { utils: { attachSpan, instrumentedQuery } } = <span
                        class="hljs-built_in">require</span>(<span class="hljs-string">'foxx-tracing'</span>)
                <span class="hljs-keyword">const</span> show = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'../show'</span>)
                <span class="hljs-keyword">const</span> commit = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'.'</span>)
                <span class="hljs-keyword">const</span> gg = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'@arangodb/general-graph'</span>)
                <span class="hljs-keyword">const</span> minimatch = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'minimatch'</span>)
                <span class="hljs-keyword">const</span> expand = <span class="hljs-built_in">require</span>(<span
                        class="hljs-string">'brace-expansion'</span>)

                <span class="hljs-keyword">const</span> cto = getComponentTagOption(__filename)

                <span class="hljs-keyword">const</span> commandColl = db._collection(SERVICE_COLLECTIONS.commands)
                <span class="hljs-keyword">const</span> snapshotColl = db._collection(SERVICE_COLLECTIONS.snapshots)
                <span class="hljs-keyword">const</span> eventColl = db._collection(SERVICE_COLLECTIONS.events)
                <span class="hljs-keyword">const</span> evtSSLinkColl = db._collection(SERVICE_COLLECTIONS.evtSSLinks)
                <span class="hljs-keyword">const</span> snapshotLinkColl =
                db._collection(SERVICE_COLLECTIONS.snapshotLinks)
                <span class="hljs-keyword">const</span> skeletonVerticesColl =
                db._collection(SERVICE_COLLECTIONS.skeletonVertices)
                <span class="hljs-keyword">const</span> skeletonEdgeHubsColl =
                db._collection(SERVICE_COLLECTIONS.skeletonEdgeHubs)
                <span class="hljs-keyword">const</span> skeletonEdgeSpokesColl =
                db._collection(SERVICE_COLLECTIONS.skeletonEdgeSpokes)
            </div>
        </div>
    </div>
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>Private</p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-keyword">const</span> getExistingUnsynced = attachSpan(<span
                    class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExistingUnsynced</span> (<span
                    class="hljs-params">collName, filter</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> queryParts = [
                aql<span class="hljs-string">`
      for v in <span class="hljs-subst">${coll}</span>
    `</span>,
                filter,
                aql<span class="hljs-string">`
      let events = (
        for e in <span class="hljs-subst">${eventColl}</span>
        filter e.meta.id == v._id
        sort e.ctime desc
        limit 2
        
        return e
      )
  
      filter !length(events) || events[0].meta.rev != v._rev
      
      return {v, e: events}
    `</span>
                ]

                <span class="hljs-keyword">const</span> query = aql.join(queryParts, <span
                        class="hljs-string">'\n'</span>)

                <span class="hljs-keyword">return</span> instrumentedQuery(query, <span class="hljs-string">'syncExQuery'</span>,
                cto)
                }, <span class="hljs-string">'getExistingUnsynced'</span>, cto)

                <span class="hljs-keyword">const</span> processExistingUnsynced = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processExistingUnsynced</span> (<span
                        class="hljs-params">cursor</span>) </span>{
                <span class="hljs-keyword">const</span> result = {
                updated: <span class="hljs-number">0</span>,
                restored: <span class="hljs-number">0</span>,
                created: <span class="hljs-number">0</span>
                }

                <span class="hljs-keyword">while</span> (cursor.hasNext()) {
                <span class="hljs-keyword">const</span> entry = cursor.next()
                <span class="hljs-keyword">const</span> [latestEvent, prevEvent] = entry.e
                <span class="hljs-keyword">const</span> eventType = latestEvent ? latestEvent.event : <span
                        class="hljs-string">'none'</span>
                <span class="hljs-keyword">let</span> old

                <span class="hljs-keyword">switch</span> (eventType) {
                <span class="hljs-keyword">case</span> CREATED:
                <span class="hljs-keyword">case</span> RESTORED:
                <span class="hljs-keyword">case</span> UPDATED:
                old = show(<span class="hljs-string">`/n/<span class="hljs-subst">${latestEvent.meta.id}</span>`</span>,
                latestEvent.ctime)[<span class="hljs-number">0</span>]
                commit(latestEvent.collection, entry.v, REPLACE, { silent: <span class="hljs-literal">true</span> }, {
                syncOnly: <span class="hljs-literal">true</span>, old })
                result.updated++

                <span class="hljs-keyword">break</span>

                <span class="hljs-keyword">case</span> DELETED:
                old = show(<span class="hljs-string">`/n/<span class="hljs-subst">${prevEvent.meta.id}</span>`</span>,
                prevEvent.ctime)[<span class="hljs-number">0</span>]

                commit(prevEvent.collection, old, RESTORE, { silent: <span class="hljs-literal">true</span> }, {
                syncOnly: <span class="hljs-literal">true</span> })
                result.restored++

                commit(prevEvent.collection, entry.v, REPLACE, { silent: <span class="hljs-literal">true</span> }, {
                syncOnly: <span class="hljs-literal">true</span>, old })
                result.updated++

                <span class="hljs-keyword">break</span>

                <span class="hljs-keyword">case</span> <span class="hljs-string">'none'</span>:
                <span class="hljs-keyword">const</span> [collection] = entry.v._id.split(<span
                        class="hljs-string">'/'</span>)
                commit(collection, entry.v, INSERT, { silent: <span class="hljs-literal">true</span> }, { syncOnly:
                <span class="hljs-literal">true</span> })
                result.created++
                }
                }
                cursor.dispose()

                <span class="hljs-keyword">return</span> result
                }, <span class="hljs-string">'processExistingUnsynced'</span>, cto)

                <span class="hljs-keyword">const</span> getDeletedUnsynced = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDeletedUnsynced</span> (<span
                        class="hljs-params">collName, filter</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> queryParts = [
                aql<span class="hljs-string">`
      for e in <span class="hljs-subst">${eventColl}</span>
      filter e.collection == <span class="hljs-subst">${collName}</span>
      filter !e["is-origin-node"]
    `</span>,
                filter,
                aql<span class="hljs-string">`
      let nodes = (
        for v in <span class="hljs-subst">${coll}</span>
        filter e.meta.id == v._id 
        return 1
      )
      
      filter !length(nodes)
      sort e.ctime desc
      collect vid = e.meta.id into events = e
      filter events[0].event != <span class="hljs-subst">${DELETED}</span>
      
      return events[0]
    `</span>
                ]

                <span class="hljs-keyword">const</span> query = aql.join(queryParts, <span
                        class="hljs-string">'\n'</span>)

                <span class="hljs-keyword">return</span> instrumentedQuery(query, <span class="hljs-string">'syncDelQuery'</span>,
                cto)
                }, <span class="hljs-string">'getDeletedUnsynced'</span>, cto)

                <span class="hljs-keyword">const</span> processDeletedUnsynced = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span
                        class="hljs-title">processDeletedUnsynced</span> (<span
                        class="hljs-params">cursor</span>) </span>{
                <span class="hljs-keyword">const</span> result = {
                deleted: <span class="hljs-number">0</span>
                }

                <span class="hljs-keyword">while</span> (cursor.hasNext()) {
                <span class="hljs-keyword">const</span> event = cursor.next()
                <span class="hljs-keyword">const</span> old = show(<span class="hljs-string">`/n/<span
                        class="hljs-subst">${event.meta.id}</span>`</span>, event.ctime)[<span
                        class="hljs-number">0</span>]

                commit(event.collection, old, REMOVE, { silent: <span class="hljs-literal">true</span> }, { syncOnly:
                <span class="hljs-literal">true</span> })
                result.deleted++
                }
                cursor.dispose()

                <span class="hljs-keyword">return</span> result
                }, <span class="hljs-string">'processDeletedUnsynced'</span>, cto)

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAvailableScopes</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                database: getDBScope(),
                graph: getGraphScope(),
                collection: getCollectionScope(collections),
                nodeExact: getNodeBraceScope(collections)
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDBScope</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/'</span>,
                collections: getNonServiceCollections
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGraphScope</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/g/*'</span>,
                prefix: <span class="hljs-string">'/g/'</span>,
                collections: searchPattern =&gt; {
                <span class="hljs-keyword">const</span> graphNames = difference(gg._list(), values(SERVICE_GRAPHS))
                <span class="hljs-keyword">const</span> matches = minimatch.match(graphNames, searchPattern)

                <span class="hljs-keyword">return</span> getMatchingCollNames(matches)
                }
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollectionScope</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/c/*'</span>,
                prefix: <span class="hljs-string">'/c/'</span>,
                collections: searchPattern =&gt; minimatch.match(collections, searchPattern)
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeBraceScope</span> (<span
                        class="hljs-params">collections</span>) </span>{
                <span class="hljs-keyword">return</span> {
                pathPattern: <span class="hljs-string">'/n/**'</span>,
                prefix: <span class="hljs-string">'/n/'</span>,
                collections: searchPattern =&gt; chain(expand(searchPattern))
                .map(pattern =&gt; pattern.split(<span class="hljs-string">'/'</span>)[<span
                        class="hljs-number">0</span>])
                .intersection(collections)
                .value(),
                filters: (searchPattern, collection) =&gt; {
                <span class="hljs-keyword">const</span> keys = []
                expand(searchPattern)
                .forEach(nid =&gt; {
                <span class="hljs-keyword">const</span> [coll, key] = nid.split(<span class="hljs-string">'/'</span>)
                <span class="hljs-keyword">if</span> (coll === collection) {
                keys.push(key)
                }
                })

                <span class="hljs-keyword">return</span> {
                existing: aql<span class="hljs-string">`filter e.meta.key in <span
                        class="hljs-subst">${keys}</span>`</span>,
                deleted: aql<span class="hljs-string">`filter v._key in <span class="hljs-subst">${keys}</span>`</span>
                }
                }
                }
                }

                <span class="hljs-keyword">const</span> sgOps = {
                [VERTEX]: {
                created: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> _key = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>.<span
                        class="hljs-subst">${key}</span>`</span>

                skeletonVerticesColl.insert({
                _key,
                validity: [
                {
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                }
                ],
                collection: collName,
                meta: pick(evtNode.meta, <span class="hljs-string">'id'</span>, <span class="hljs-string">'key'</span>)
                })
                },
                deleted: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> _key = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>.<span
                        class="hljs-subst">${key}</span>`</span>

                query<span class="hljs-string">`
        for sv in <span class="hljs-subst">${skeletonVerticesColl}</span>
        filter sv._key == <span class="hljs-subst">${_key}</span>
        
        let v1 = pop(sv.validity)
        let v2 = last(sv.validity)
        let v3 = merge(v2, { valid_until: <span class="hljs-subst">${evtNode.ctime}</span> })
        let v4 = push(v1, v3)
        
        update sv with { validity: v4 } in <span class="hljs-subst">${skeletonVerticesColl}</span>
      `</span>
                },
                updated: noop,
                restored: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> _key = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>.<span
                        class="hljs-subst">${key}</span>`</span>

                query<span class="hljs-string">`
        for sv in <span class="hljs-subst">${skeletonVerticesColl}</span>
        filter sv._key == <span class="hljs-subst">${_key}</span>
        
        let v1 = push(sv.validity, { valid_since: <span class="hljs-subst">${evtNode.ctime}</span>, valid_until: <span
                            class="hljs-subst">${Number.MAX_VALUE}</span> })
        
        update sv with { validity: v1 } in <span class="hljs-subst">${skeletonVerticesColl}</span>
      `</span>
                }
                },
                [EDGE]: {
                created: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> skCollMap = getSkCollMap()
                <span class="hljs-keyword">const</span> _key = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>.<span
                        class="hljs-subst">${key}</span>`</span>
                <span class="hljs-keyword">const</span> hub = skeletonEdgeHubsColl.insert({
                _key,
                validity: [
                {
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                }
                ],
                collection: collName,
                meta: pick(evtNode.meta, <span class="hljs-string">'id'</span>, <span class="hljs-string">'key'</span>,
                <span class="hljs-string">'from'</span>, <span class="hljs-string">'to'</span>)
                })._id

                <span class="hljs-keyword">const</span> [fCollName, fKey] = evtNode.meta.from.split(<span
                        class="hljs-string">'/'</span>)
                <span class="hljs-keyword">const</span> fromKey = <span class="hljs-string">`<span class="hljs-subst">${fCollName}</span>.<span
                        class="hljs-subst">${fKey}</span>`</span>
                <span class="hljs-keyword">const</span> _from = <span class="hljs-string">`<span class="hljs-subst">${skCollMap[fCollName]}</span>/<span
                        class="hljs-subst">${fromKey}</span>`</span>
                <span class="hljs-keyword">const</span> [tCollName, tKey] = evtNode.meta.to.split(<span
                        class="hljs-string">'/'</span>)
                <span class="hljs-keyword">const</span> toKey = <span class="hljs-string">`<span class="hljs-subst">${tCollName}</span>.<span
                        class="hljs-subst">${tKey}</span>`</span>
                <span class="hljs-keyword">const</span> _to = <span class="hljs-string">`<span class="hljs-subst">${skCollMap[tCollName]}</span>/<span
                        class="hljs-subst">${toKey}</span>`</span>

                skeletonEdgeSpokesColl.insert([
                {
                hub,
                validity: [
                {
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                }
                ],
                _from,
                _to:
                hub
                },
                {
                hub,
                validity: [
                {
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                }
                ],
                _from: hub,
                _to
                }
                ])
                },
                deleted: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> hid = <span class="hljs-string">`<span class="hljs-subst">${SERVICE_COLLECTIONS.skeletonEdgeHubs}</span>/<span
                        class="hljs-subst">${collName}</span>.<span class="hljs-subst">${key}</span>`</span>

                query<span class="hljs-string">`
        for seh in <span class="hljs-subst">${skeletonEdgeHubsColl}</span>
        filter seh._id == <span class="hljs-subst">${hid}</span>
        
        let v1 = pop(seh.validity)
        let v2 = last(seh.validity)
        let v3 = merge(v2, { valid_until: <span class="hljs-subst">${evtNode.ctime}</span> })
        let v4 = push(v1, v3)
        
        update seh with { validity: v4 } in <span class="hljs-subst">${skeletonEdgeHubsColl}</span>
      `</span>
                query<span class="hljs-string">`
        for ses in <span class="hljs-subst">${skeletonEdgeSpokesColl}</span>
        filter ses.hub == <span class="hljs-subst">${hid}</span>
        
        let v2 = last(ses.validity)
        filter v2.valid_until &gt; <span class="hljs-subst">${evtNode.ctime}</span>
        
        let v1 = pop(ses.validity)
        let v3 = merge(v2, { valid_until: <span class="hljs-subst">${evtNode.ctime}</span> })
        let v4 = push(v1, v3)
        
        update ses with { validity: v4 } in <span class="hljs-subst">${skeletonEdgeSpokesColl}</span>
      `</span>
                },
                updated: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> endpoints = intersection(<span
                        class="hljs-built_in">Object</span>.keys(evtNode.meta), [<span
                        class="hljs-string">'fromNew'</span>, <span class="hljs-string">'toNew'</span>, <span
                        class="hljs-string">'fromOld'</span>, <span class="hljs-string">'toOld'</span>])
                <span class="hljs-keyword">if</span> (endpoints.length) {
                <span class="hljs-keyword">const</span> skCollMap = getSkCollMap()
                <span class="hljs-keyword">const</span> fromOld = getEndpoint(skCollMap, evtNode, <span
                        class="hljs-string">'from'</span>, <span class="hljs-string">'Old'</span>)
                <span class="hljs-keyword">const</span> fromNew = getEndpoint(skCollMap, evtNode, <span
                        class="hljs-string">'from'</span>, <span class="hljs-string">'New'</span>)
                <span class="hljs-keyword">const</span> toOld = getEndpoint(skCollMap, evtNode, <span
                        class="hljs-string">'to'</span>, <span class="hljs-string">'Old'</span>)
                <span class="hljs-keyword">const</span> toNew = getEndpoint(skCollMap, evtNode, <span
                        class="hljs-string">'to'</span>, <span class="hljs-string">'New'</span>)
                <span class="hljs-keyword">const</span> from = filter([fromOld, fromNew])
                <span class="hljs-keyword">const</span> to = filter([toOld, toNew])

                <span class="hljs-keyword">const</span> hub = <span class="hljs-string">`<span class="hljs-subst">${SERVICE_COLLECTIONS.skeletonEdgeHubs}</span>/<span
                        class="hljs-subst">${collName}</span>.<span class="hljs-subst">${key}</span>`</span>
                <span class="hljs-keyword">const</span> edges = query<span class="hljs-string">`
          for ses in <span class="hljs-subst">${skeletonEdgeSpokesColl}</span>
          
          filter ses.hub == <span class="hljs-subst">${hub}</span>
          filter ses._from in <span class="hljs-subst">${from}</span> || ses._to in <span
                            class="hljs-subst">${to}</span>
          
          return ses
        `</span>.toArray()
                <span class="hljs-keyword">const</span> inserts = []
                <span class="hljs-keyword">const</span> updateKeys = []
                <span class="hljs-keyword">const</span> updateValues = []
                <span class="hljs-keyword">const</span> epMap = { fromOld, toOld, fromNew, toNew }

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ep <span
                        class="hljs-keyword">of</span> endpoints) {
                <span class="hljs-keyword">const</span> field = <span class="hljs-string">`_<span class="hljs-subst">${ep.slice(0, -3)}</span>`</span>
                <span class="hljs-keyword">let</span> e = edges.find(e =&gt; e[field] === epMap[ep])

                <span class="hljs-keyword">if</span> (e) {
                <span class="hljs-keyword">const</span> type = ep.slice(-<span class="hljs-number">3</span>)
                <span class="hljs-keyword">switch</span> (type.toLowerCase()) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'old'</span>:
                <span class="hljs-keyword">const</span> v = last(e.validity)
                v.valid_until = evtNode.ctime

                <span class="hljs-keyword">break</span>

                <span class="hljs-keyword">case</span> <span class="hljs-string">'new'</span>:
                e.validity.push({
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                })
                }

                updateKeys.push(e._key)
                updateValues.push(pick(e, <span class="hljs-string">'validity'</span>))
                } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">const</span> other = field === <span class="hljs-string">'_from'</span> ?
                <span class="hljs-string">'_to'</span> : <span class="hljs-string">'_from'</span>

                inserts.push({
                hub,
                validity: [
                {
                valid_since: evtNode.ctime,
                valid_until: <span class="hljs-built_in">Number</span>.MAX_VALUE
                }
                ],
                [field]: epMap[ep],
                [other]: hub
                })
                }
                }

                skeletonEdgeSpokesColl.insert(inserts)
                skeletonEdgeSpokesColl.update(updateKeys, updateValues)
                }
                },
                restored: (collName, key, evtNode) =&gt; {
                <span class="hljs-keyword">const</span> hid = <span class="hljs-string">`<span class="hljs-subst">${SERVICE_COLLECTIONS.skeletonEdgeHubs}</span>/<span
                        class="hljs-subst">${collName}</span>.<span class="hljs-subst">${key}</span>`</span>

                query<span class="hljs-string">`
        for seh in <span class="hljs-subst">${skeletonEdgeHubsColl}</span>
        filter seh._id == <span class="hljs-subst">${hid}</span>
        
        let v1 = push(seh.validity, { valid_since: <span class="hljs-subst">${evtNode.ctime}</span>, valid_until: <span
                            class="hljs-subst">${Number.MAX_VALUE}</span> })
        
        update seh with { validity: v1 } in <span class="hljs-subst">${skeletonEdgeHubsColl}</span>
      `</span>

                query<span class="hljs-string">`
        for ses in <span class="hljs-subst">${skeletonEdgeSpokesColl}</span>
        filter ses.hub == <span class="hljs-subst">${hid}</span>
        
        let v2 = last(ses.validity)
        filter has(v2, 'valid_until')
        sort v2.valid_until desc
        limit 2
        
        let v1 = push(ses.validity, { valid_since: <span class="hljs-subst">${evtNode.ctime}</span>, valid_until: <span
                            class="hljs-subst">${Number.MAX_VALUE}</span> })
        
        update ses with { validity: v1 } in <span class="hljs-subst">${skeletonEdgeSpokesColl}</span>
      `</span>
                }
                }
                }

                <span class="hljs-keyword">const</span> compatiblePrevEvents = {
                [INSERT]: [COLL_INIT],
                [UPDATE]: [CREATED, UPDATED, RESTORED],
                [REPLACE]: [CREATED, UPDATED, RESTORED],
                [REMOVE]: [CREATED, UPDATED, RESTORED],
                [RESTORE]: [DELETED]
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEndpoint</span> (<span
                        class="hljs-params">skCollMap, evtNode, end, age</span>) </span>{
                <span class="hljs-keyword">let</span> endpoint = <span class="hljs-literal">null</span>
                <span class="hljs-keyword">const</span> ep = <span class="hljs-string">`<span
                        class="hljs-subst">${end}</span><span class="hljs-subst">${age}</span>`</span>

                <span class="hljs-keyword">if</span> (evtNode.meta[ep]) {
                <span class="hljs-keyword">const</span> [collName, key] = evtNode.meta[ep].split(<span
                        class="hljs-string">'/'</span>)
                <span class="hljs-keyword">const</span> epKey = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>.<span
                        class="hljs-subst">${key}</span>`</span>

                endpoint = <span class="hljs-string">`<span class="hljs-subst">${skCollMap[collName]}</span>/<span
                        class="hljs-subst">${epKey}</span>`</span>
                }

                <span class="hljs-keyword">return</span> endpoint
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSkCollMap</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">const</span> edgeCollections = getNonServiceCollections().filter(coll =&gt;
                getCollectionType(coll) === EDGE)
                <span class="hljs-keyword">const</span> vertexCollections = getNonServiceCollections().filter(
                coll =&gt; getCollectionType(coll) === VERTEX)

                <span class="hljs-keyword">const</span> skCollMap = {}
                vertexCollections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span
                        class="hljs-params">coll</span>) </span>{ skCollMap[coll] = SERVICE_COLLECTIONS.skeletonVertices
                })
                edgeCollections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span
                        class="hljs-params">coll</span>) </span>{ skCollMap[coll] = SERVICE_COLLECTIONS.skeletonEdgeHubs
                })

                <span class="hljs-keyword">return</span> skCollMap
                }

                <span class="hljs-keyword">const</span> getTransientSnapshotOriginFor = memoize(coll =&gt; {
                <span class="hljs-keyword">const</span> key = <span class="hljs-string">`origin-<span
                        class="hljs-subst">${coll._id}</span>`</span>

                <span class="hljs-keyword">return</span> {
                _id: <span class="hljs-string">`<span class="hljs-subst">${snapshotColl.name()}</span>/<span
                        class="hljs-subst">${key}</span>`</span>,
                _key: key,
                <span class="hljs-string">'is-origin-node'</span>: <span class="hljs-literal">true</span>,
                data: {}
                }
                }, coll =&gt; coll.name())

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureEventSupernode</span> (<span
                        class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (!eventColl.exists(TRANSIENT_EVENT_SUPERNODE)) {
                <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> superOrigin = <span class="hljs-built_in">Object</span>.assign({
                ctime: dbtime() }, TRANSIENT_EVENT_SUPERNODE)
                eventColl.insert(superOrigin, {
                waitForSync: <span class="hljs-literal">true</span>,
                silent: <span class="hljs-literal">true</span>
                })
                } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-built_in">console</span>.error(e.stack)
                <span class="hljs-keyword">if</span> (
                e.errorNum !==
                ARANGO_ERRORS.ERROR_ARANGO_UNIQUE_CONSTRAINT_VIOLATED.code
                ) {
                <span class="hljs-keyword">throw</span> e
                }
                }
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSelector</span> (<span
                        class="hljs-params">collName, node, ignoreRevs</span>) </span>{
                <span class="hljs-keyword">const</span> selectorKeys = [<span class="hljs-string">'_key'</span>, <span
                        class="hljs-string">'_id'</span>]
                <span class="hljs-keyword">if</span> (!ignoreRevs) {
                selectorKeys.push(<span class="hljs-string">'_rev'</span>)
                }

                <span class="hljs-keyword">const</span> selector = pick(node, selectorKeys)
                <span class="hljs-keyword">if</span> (!selector._id) {
                selector._id = <span class="hljs-string">`<span class="hljs-subst">${collName}</span>/<span
                        class="hljs-subst">${selector._key}</span>`</span>
                }

                <span class="hljs-keyword">return</span> selector
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rejectIfIncompatible</span> (<span
                        class="hljs-params">op, prevEvent, selector</span>) </span>{
                <span class="hljs-keyword">if</span> (!compatiblePrevEvents[op].includes(prevEvent.event)) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span
                        class="hljs-built_in">Error</span>(
                <span class="hljs-string">`Event log not found for node with _id: <span class="hljs-subst">${selector._id}</span>. Run \`sync\` first to make the event log catch up.`</span>
                )
                e.errorNum = ARANGO_ERRORS.ERROR_ARANGO_DOCUMENT_NOT_FOUND.code
                e.errorMessage = e.message

                <span class="hljs-keyword">throw</span> e
                }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureSnapshotOriginNode</span> (<span
                        class="hljs-params">collName</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> origin = getTransientSnapshotOriginFor(coll)

                <span class="hljs-keyword">if</span> (!snapshotColl.exists(origin)) {
                <span class="hljs-keyword">try</span> {
                snapshotColl.insert(origin, {
                waitForSync: <span class="hljs-literal">true</span>,
                silent: <span class="hljs-literal">true</span>
                })
                } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-built_in">console</span>.error(e.stack)
                <span class="hljs-keyword">if</span> (
                e.errorNum !==
                ARANGO_ERRORS.ERROR_ARANGO_UNIQUE_CONSTRAINT_VIOLATED.code
                ) {
                <span class="hljs-keyword">throw</span> e
                }
                }
                }

                <span class="hljs-keyword">return</span> origin
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSnapshotLink</span> (<span
                        class="hljs-params">fromSSNodeId, toSSNodeId</span>) </span>{
                <span class="hljs-keyword">const</span> snapshotLinkEdge = {
                _from: fromSSNodeId,
                _to: toSSNodeId
                }

                <span class="hljs-keyword">return</span> snapshotLinkColl.insert(snapshotLinkEdge, { returnNew: <span
                        class="hljs-literal">true</span> }).new
                }
            </div>
        </div>
    </div>
    <div class="segment">
        <div class="comments ">
            <div class="wrapper"><p>Public</p></div>
        </div>
        <div class="code">
            <div class="wrapper"><span class="hljs-keyword">const</span> SYNC_MAP = <span
                    class="hljs-built_in">Object</span>.freeze({
                [EXISTING]: {
                get: getExistingUnsynced,
                proc: processExistingUnsynced
                },
                [SYNC_DELETED]: {
                get: getDeletedUnsynced,
                proc: processDeletedUnsynced
                }
                })

                <span class="hljs-keyword">const</span> ensureEventOriginNode = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ensureEventOriginNode</span> (<span
                        class="hljs-params">collName</span>) </span>{
                ensureEventSupernode()
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> tOrigin = getTransientEventOriginFor(coll)

                <span class="hljs-keyword">if</span> (!eventColl.exists(tOrigin)) {
                <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">let</span> origin = <span class="hljs-built_in">Object</span>.assign({ ctime:
                dbtime() }, tOrigin)
                origin = eventColl.insert(origin)

                insertCommandEdge(TRANSIENT_EVENT_SUPERNODE, origin, {}, {})

                <span class="hljs-keyword">const</span> snapshotOrigin = ensureSnapshotOriginNode(collName)
                insertEvtSSLink(origin._id, snapshotOrigin._id)
                } <span class="hljs-keyword">catch</span> (e) {
                <span class="hljs-built_in">console</span>.error(e.stack)
                <span class="hljs-keyword">if</span> (
                e.errorNum !==
                ARANGO_ERRORS.ERROR_ARANGO_UNIQUE_CONSTRAINT_VIOLATED.code
                ) {
                <span class="hljs-keyword">throw</span> e
                }
                }
                }
                }, <span class="hljs-string">'ensureEventOriginNode'</span>, cto)

                <span class="hljs-keyword">const</span> getLatestEvent = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">getLatestEvent</span> (<span
                        class="hljs-params">node, coll</span>) </span>{
                <span class="hljs-keyword">let</span> latest

                <span class="hljs-keyword">const</span> cursor = query<span class="hljs-string">`
    for e in <span class="hljs-subst">${eventColl}</span>
      filter e.meta.id == <span class="hljs-subst">${node._id}</span>
      sort e['hops-from-origin'] desc
      limit 1
    return e
  `</span>
                <span class="hljs-keyword">if</span> (cursor.hasNext()) {
                latest = cursor.next()
                } <span class="hljs-keyword">else</span> {
                latest = getTransientEventOriginFor(coll)
                }

                cursor.dispose()

                <span class="hljs-keyword">return</span> latest
                }, <span class="hljs-string">'getLatestEvent'</span>, cto)

                <span class="hljs-keyword">const</span> getTransientEventOriginFor = attachSpan(memoize(coll =&gt; {
                <span class="hljs-keyword">const</span> key = <span class="hljs-string">`origin-<span
                        class="hljs-subst">${coll._id}</span>`</span>
                <span class="hljs-keyword">const</span> snapshot = getTransientSnapshotOriginFor(coll)
                <span class="hljs-keyword">const</span> id = <span class="hljs-string">`<span class="hljs-subst">${eventColl.name()}</span>/<span
                        class="hljs-subst">${key}</span>`</span>

                <span class="hljs-keyword">return</span> {
                _id: id,
                _key: key,
                <span class="hljs-string">'is-origin-node'</span>: <span class="hljs-literal">true</span>,
                collection: coll.name(),
                meta: { id },
                event: COLL_INIT,
                <span class="hljs-string">'last-snapshot'</span>: snapshot._id,
                <span class="hljs-string">'hops-from-last-snapshot'</span>: <span class="hljs-number">1</span>,
                <span class="hljs-string">'hops-from-origin'</span>: <span class="hljs-number">0</span>
                }
                }, coll =&gt; coll.name()), <span class="hljs-string">'getTransientEventOriginFor'</span>, cto)

                <span class="hljs-keyword">const</span> getTransientOrCreateLatestSnapshot = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTransientOrCreateLatestSnapshot</span> (<span
                        class="hljs-params">collName, lastEvtNode, node, ctime</span>) </span>{
                <span class="hljs-keyword">const</span> ssInterval = snapshotInterval(collName)

                <span class="hljs-keyword">let</span> ssNode = <span class="hljs-literal">null</span>
                <span class="hljs-keyword">let</span> hopsFromLast
                <span class="hljs-keyword">let</span> prevSSid
                <span class="hljs-keyword">if</span> (ssInterval &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (
                lastEvtNode[<span class="hljs-string">'last-snapshot'</span>] &amp;&amp;
                lastEvtNode[<span class="hljs-string">'hops-from-last-snapshot'</span>] &lt; ssInterval
                ) {
                ssNode = {
                _id: lastEvtNode[<span class="hljs-string">'last-snapshot'</span>]
                }
                hopsFromLast = lastEvtNode[<span class="hljs-string">'hops-from-last-snapshot'</span>] + <span
                        class="hljs-number">1</span>
                } <span class="hljs-keyword">else</span> {
                ssNode = {
                ctime,
                data: node
                }
                ssNode = snapshotColl.insert(ssNode, { returnNew: <span class="hljs-literal">true</span> }).new
                hopsFromLast = <span class="hljs-number">1</span>
                prevSSid = lastEvtNode[<span class="hljs-string">'last-snapshot'</span>]

                insertSnapshotLink(prevSSid, ssNode._id)
                }
                }

                <span class="hljs-keyword">return</span> { ssNode, hopsFromLast, prevSSid }
                },
                <span class="hljs-string">'getTransientOrCreateLatestSnapshot'</span>, cto)

                <span class="hljs-keyword">const</span> insertCommandEdge = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">insertCommandEdge</span> (<span
                        class="hljs-params">prevEvent, evtNode, oldNode, newNode</span>) </span>{
                <span class="hljs-keyword">const</span> cmdEdge = {
                _from: prevEvent._id,
                _to: evtNode._id,
                command: jiff.diff(oldNode, newNode, {})
                }
                <span class="hljs-keyword">if</span> (prevEvent[<span class="hljs-string">'is-origin-node'</span>]) {
                cmdEdge.meta = {
                id: newNode._id
                }
                }

                <span class="hljs-keyword">return</span> commandColl.insert(cmdEdge, { returnNew: <span
                        class="hljs-literal">true</span> }).new
                }, <span class="hljs-string">'insertCommandEdge'</span>, cto)

                <span class="hljs-keyword">const</span> insertEventNode = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">insertEventNode</span> (<span
                        class="hljs-params">nodeMeta, time, event, ssData, prevEvent, collName</span>) </span>{
                <span class="hljs-keyword">const</span> evtNode = {
                meta: metaize(cloneDeep(nodeMeta)),
                ctime: time,
                event,
                collection: collName
                }

                <span class="hljs-keyword">if</span> (ssData.ssNode) {
                merge(evtNode, {
                <span class="hljs-string">'last-snapshot'</span>: ssData.ssNode._id,
                <span class="hljs-string">'hops-from-last-snapshot'</span>: ssData.hopsFromLast,
                <span class="hljs-string">'hops-from-origin'</span>: prevEvent[<span class="hljs-string">'hops-from-origin'</span>]
                + <span class="hljs-number">1</span>
                })
                }

                <span class="hljs-keyword">return</span> eventColl.insert(evtNode, { returnNew: <span
                        class="hljs-literal">true</span> }).new
                }, <span class="hljs-string">'insertEventNode'</span>, cto)

                <span class="hljs-keyword">const</span> insertEvtSSLink = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">insertEvtSSLink</span> (<span
                        class="hljs-params">evtNodeId, ssNodeId</span>) </span>{
                <span class="hljs-keyword">const</span> evtSSLinkEdge = {
                _from: evtNodeId,
                _to: ssNodeId
                }

                <span class="hljs-keyword">return</span> evtSSLinkColl.insert(evtSSLinkEdge, { returnNew: <span
                        class="hljs-literal">true</span> }).new
                }, <span class="hljs-string">'insertEvtSSLink'</span>, cto)

                <span class="hljs-keyword">const</span> prepInsert = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">prepInsert</span> (<span
                        class="hljs-params">collName, node, { syncOnly = false } = {}</span>) </span>{
                <span class="hljs-keyword">if</span> (!syncOnly &amp;&amp; (node._id || node._key)) {
                <span class="hljs-keyword">const</span> nid = node._id || <span class="hljs-string">`<span
                        class="hljs-subst">${collName}</span>/<span class="hljs-subst">${node._key}</span>`</span>
                <span class="hljs-keyword">const</span> event = eventColl.firstExample(<span class="hljs-string">'meta.id'</span>,
                nid, <span class="hljs-string">'event'</span>, DELETED)
                <span class="hljs-keyword">if</span> (event) {
                <span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span
                        class="hljs-built_in">Error</span>(
                <span class="hljs-string">`Event log found for node with _id: <span class="hljs-subst">${nid}</span>. Restore to reuse, or specify a new id/key.`</span>
                )
                e.errorNum = ARANGO_ERRORS.ERROR_ARANGO_UNIQUE_CONSTRAINT_VIOLATED.code
                e.errorMessage = e.message

                <span class="hljs-keyword">throw</span> e
                }
                }

                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">let</span> result
                <span class="hljs-keyword">if</span> (syncOnly) {
                result = <span class="hljs-built_in">Object</span>.assign(pick(node, <span
                        class="hljs-string">'_id'</span>, <span class="hljs-string">'_key'</span>, <span
                        class="hljs-string">'_rev'</span>), { <span class="hljs-keyword">new</span>: node })
                } <span class="hljs-keyword">else</span> {
                result = coll.insert(node, {
                returnNew: <span class="hljs-literal">true</span>
                })
                }

                <span class="hljs-keyword">const</span> time = dbtime()
                result.old = {}
                <span class="hljs-keyword">const</span> event = CREATED
                <span class="hljs-keyword">const</span> prevEvent = getLatestEvent(result, coll)

                rejectIfIncompatible(INSERT, prevEvent, result)

                <span class="hljs-keyword">const</span> ssData = getTransientOrCreateLatestSnapshot(
                collName,
                prevEvent,
                result.new,
                time
                )

                ensureEventOriginNode(collName)

                <span class="hljs-keyword">return</span> { result, event, time, prevEvent, ssData }
                }, <span class="hljs-string">'prepInsert'</span>, cto)

                <span class="hljs-keyword">const</span> prepRestore = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">prepRestore</span> (<span
                        class="hljs-params">collName, node, { syncOnly = false } = {}</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">let</span> result
                <span class="hljs-keyword">if</span> (syncOnly) {
                result = <span class="hljs-built_in">Object</span>.assign(pick(node, <span
                        class="hljs-string">'_id'</span>, <span class="hljs-string">'_key'</span>, <span
                        class="hljs-string">'_rev'</span>), { <span class="hljs-keyword">new</span>: node })
                } <span class="hljs-keyword">else</span> {
                result = coll.insert(node, {
                returnNew: <span class="hljs-literal">true</span>
                })
                }

                <span class="hljs-keyword">const</span> time = dbtime()
                result.old = {}
                <span class="hljs-keyword">const</span> event = RESTORED
                <span class="hljs-keyword">const</span> prevEvent = getLatestEvent(result, coll)

                rejectIfIncompatible(RESTORE, prevEvent, result)

                <span class="hljs-keyword">const</span> ssData = getTransientOrCreateLatestSnapshot(
                collName,
                prevEvent,
                result.new,
                time
                )

                ensureEventOriginNode(collName)

                <span class="hljs-keyword">return</span> { result, event, time, prevEvent, ssData }
                }, <span class="hljs-string">'prepRestore'</span>, cto)

                <span class="hljs-keyword">const</span> prepReplace = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepReplace</span> (<span
                        class="hljs-params">collName, node, { ignoreRevs = true, syncOnly = false, old = null } = {}</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> selector = getSelector(collName, node, ignoreRevs)
                <span class="hljs-keyword">const</span> prevEvent = getLatestEvent(selector, coll)

                rejectIfIncompatible(REPLACE, prevEvent, selector)

                <span class="hljs-keyword">let</span> result
                <span class="hljs-keyword">if</span> (syncOnly) {
                result = <span class="hljs-built_in">Object</span>.assign(pick(node, <span
                        class="hljs-string">'_id'</span>, <span class="hljs-string">'_key'</span>, <span
                        class="hljs-string">'_rev'</span>), { <span class="hljs-keyword">new</span>: node, old })
                } <span class="hljs-keyword">else</span> {
                result = coll.replace(selector, node, {
                returnNew: <span class="hljs-literal">true</span>,
                returnOld: <span class="hljs-literal">true</span>
                })
                }

                <span class="hljs-keyword">const</span> time = dbtime()
                <span class="hljs-keyword">const</span> event = UPDATED
                <span class="hljs-keyword">const</span> ssData = getTransientOrCreateLatestSnapshot(
                collName,
                prevEvent,
                result.new,
                time
                )

                <span class="hljs-keyword">if</span> (!syncOnly &amp;&amp; result.old._rev !== prevEvent.meta.rev) {
                result.old = show(<span class="hljs-string">`/n/<span class="hljs-subst">${selector._id}</span>`</span>,
                prevEvent.ctime)[<span class="hljs-number">0</span>]
                }

                <span class="hljs-keyword">return</span> { result, event, time, prevEvent, ssData }
                }, <span class="hljs-string">'prepReplace'</span>, cto)

                <span class="hljs-keyword">const</span> prepUpdate = attachSpan(
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepUpdate</span> (<span
                        class="hljs-params">collName, node, { keepNull = true, mergeObjects = true, ignoreRevs = true } = {}</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> selector = getSelector(collName, node, ignoreRevs)
                <span class="hljs-keyword">const</span> prevEvent = getLatestEvent(selector, coll)

                rejectIfIncompatible(UPDATE, prevEvent, selector)

                <span class="hljs-keyword">const</span> result = coll.update(selector, node, {
                returnNew: <span class="hljs-literal">true</span>,
                returnOld: <span class="hljs-literal">true</span>,
                keepNull,
                mergeObjects
                })

                <span class="hljs-keyword">const</span> time = dbtime()
                <span class="hljs-keyword">const</span> event = UPDATED
                <span class="hljs-keyword">const</span> ssData = getTransientOrCreateLatestSnapshot(
                collName,
                prevEvent,
                result.new,
                time
                )

                <span class="hljs-keyword">if</span> (result.old._rev !== prevEvent.meta.rev) {
                result.old = show(<span class="hljs-string">`/n/<span class="hljs-subst">${selector._id}</span>`</span>,
                prevEvent.ctime)[<span class="hljs-number">0</span>]
                }

                <span class="hljs-keyword">return</span> { result, event, time, prevEvent, ssData }
                }, <span class="hljs-string">'prepUpdate'</span>, cto)

                <span class="hljs-keyword">const</span> prepRemove = attachSpan(<span class="hljs-function"><span
                        class="hljs-keyword">function</span> <span class="hljs-title">prepRemove</span> (<span
                        class="hljs-params">collName, node, { ignoreRevs = true, syncOnly = false } = {}</span>) </span>{
                <span class="hljs-keyword">const</span> coll = db._collection(collName)
                <span class="hljs-keyword">const</span> selector = getSelector(collName, node, ignoreRevs)
                <span class="hljs-keyword">const</span> prevEvent = getLatestEvent(selector, coll)

                rejectIfIncompatible(REMOVE, prevEvent, selector)

                <span class="hljs-keyword">let</span> result
                <span class="hljs-keyword">if</span> (syncOnly) {
                result = <span class="hljs-built_in">Object</span>.assign(pick(node, <span
                        class="hljs-string">'_id'</span>, <span class="hljs-string">'_key'</span>, <span
                        class="hljs-string">'_rev'</span>), { old: node })
                } <span class="hljs-keyword">else</span> {
                result = coll.remove(selector, {
                returnOld: <span class="hljs-literal">true</span>
                })
                }

                <span class="hljs-keyword">const</span> time = dbtime()
                result.new = {}
                <span class="hljs-keyword">const</span> event = DELETED
                <span class="hljs-keyword">const</span> ssData = {
                ssNode: {
                _id: prevEvent[<span class="hljs-string">'last-snapshot'</span>]
                },
                hopsFromLast: prevEvent[<span class="hljs-string">'hops-from-last-snapshot'</span>] + <span
                        class="hljs-number">1</span>
                }

                <span class="hljs-keyword">if</span> (!syncOnly &amp;&amp; result.old._rev !== prevEvent.meta.rev) {
                result.old = show(<span class="hljs-string">`/n/<span class="hljs-subst">${selector._id}</span>`</span>,
                prevEvent.ctime)[<span class="hljs-number">0</span>]
                }

                <span class="hljs-keyword">return</span> { result, event, time, prevEvent, ssData }
                }, <span class="hljs-string">'prepRemove'</span>, cto)

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span
                        class="hljs-title">metaize</span> (<span class="hljs-params">obj</span>) </span>{
                <span class="hljs-keyword">return</span> mapKeys(obj, (v, k) =&gt; k.replace(<span class="hljs-regexp">/^_/</span>,
                <span class="hljs-string">''</span>))
                }

                <span class="hljs-keyword">const</span> updateSkeletonGraph = attachSpan(<span
                        class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateSkeletonGraph</span> (<span
                        class="hljs-params">evtNode</span>) </span>{
                <span class="hljs-keyword">const</span> nid = evtNode.meta.id
                <span class="hljs-keyword">const</span> [collName, key] = nid.split(<span class="hljs-string">'/'</span>)
                <span class="hljs-keyword">const</span> collType = getCollectionType(collName)

                sgOps[collType][evtNode.event](collName, key, evtNode)
                }, <span class="hljs-string">'updateSkeletonGraph'</span>, cto)

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeAndSearchPatternFor</span> (<span
                        class="hljs-params">path</span>) </span>{
                <span class="hljs-keyword">const</span> collections = getNonServiceCollections()
                <span class="hljs-keyword">const</span> scopes = getAvailableScopes(collections)

                <span class="hljs-keyword">const</span> scope = find(scopes, scope =&gt; minimatch(path,
                scope.pathPattern))
                <span class="hljs-keyword">const</span> searchPattern = scope.prefix ?
                path.substring(scope.prefix.length) : path

                <span class="hljs-keyword">return</span> { scope, searchPattern }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeFilters</span> (<span
                        class="hljs-params">scope, searchPattern, collection</span>) </span>{
                <span class="hljs-keyword">return</span> scope.filters ? scope.filters(searchPattern, collection) : {
                existing: aql.literal(<span class="hljs-string">''</span>),
                deleted: aql.literal(<span class="hljs-string">''</span>)
                }
                }

                <span class="hljs-built_in">module</span>.exports = {
                ensureEventOriginNode,
                getLatestEvent,
                getTransientEventOriginFor,
                getTransientOrCreateLatestSnapshot,
                insertCommandEdge,
                insertEventNode,
                insertEvtSSLink,
                prepInsert,
                prepRestore,
                prepReplace,
                prepUpdate,
                prepRemove,
                metaize,
                updateSkeletonGraph,
                SYNC_MAP,
                getScopeAndSearchPatternFor,
                getScopeFilters
                }
            </div>
        </div>
    </div>
</div>
</body>
</html>