<!DOCTYPE html><html lang="en"><head><title>lib/operations/helpers</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="lib/operations/helpers"><meta name="groc-project-path" content="lib/operations/helpers.js"><meta name="groc-github-url" content="https://github.com/RecallGraph/RecallGraph"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/RecallGraph/RecallGraph/blob/master/lib/operations/helpers.js">lib/operations/helpers.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>eslint eqeqeq:0 </p></div></div><div class="code"><div class="wrapper"><span class="hljs-pi">'use strict'</span>

<span class="hljs-keyword">const</span> {
  difference, values, chain, concat, find, isString, stubFalse, negate, identity, isFunction, memoize
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">const</span> minimatch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'minimatch'</span>)
<span class="hljs-keyword">const</span> expand = <span class="hljs-built_in">require</span>(<span class="hljs-string">'brace-expansion'</span>)
<span class="hljs-keyword">const</span> gg = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@arangodb/general-graph'</span>)
<span class="hljs-keyword">const</span> { getCollectionType, getComponentTagOption } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers'</span>)
<span class="hljs-keyword">const</span> {
  SERVICE_GRAPHS, SERVICE_COLLECTIONS, TRANSIENT_EVENT_SUPERNODE, COLL_TYPES_REF, SORT_TYPES
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../constants'</span>)
<span class="hljs-keyword">const</span> { aql, db } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@arangodb'</span>)
<span class="hljs-keyword">const</span> jsep = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsep'</span>)
<span class="hljs-keyword">const</span> { utils: { attachSpan } } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'foxx-tracing'</span>)

<span class="hljs-keyword">const</span> commandColl = db._collection(SERVICE_COLLECTIONS.commands)
<span class="hljs-keyword">const</span> cto = getComponentTagOption(__filename)

<span class="hljs-keyword">const</span> OP_MAP = <span class="hljs-built_in">Object</span>.freeze({
  <span class="hljs-string">'typeof'</span>: (val) =&gt; <span class="hljs-keyword">typeof</span> val,
  glob: (str, pattern) =&gt; isString(pattern) &amp;&amp; isString(str) &amp;&amp; minimatch(str, pattern),
  regx: (str, pattern) =&gt; {
    <span class="hljs-keyword">if</span> (isString(pattern) &amp;&amp; isString(str)) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> regex = getRegExp(pattern)

        <span class="hljs-keyword">return</span> regex.test(str)
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-built_in">console</span>.error(e.stack)
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
})
exports.OP_MAP = OP_MAP

jsep.addBinaryOp(<span class="hljs-string">'=~'</span>, <span class="hljs-number">6</span>)
jsep.addBinaryOp(<span class="hljs-string">'=*'</span>, <span class="hljs-number">6</span>)
jsep.addBinaryOp(<span class="hljs-string">'in'</span>, <span class="hljs-number">6</span>)
jsep.addBinaryOp(<span class="hljs-string">'**'</span>, <span class="hljs-number">4</span>)
jsep.addLiteral(<span class="hljs-string">'$Math'</span>, <span class="hljs-built_in">Math</span>)
jsep.addLiteral(<span class="hljs-string">'$_'</span>, _)
jsep.addLiteral(<span class="hljs-string">'$RG'</span>, OP_MAP)

<span class="hljs-keyword">const</span> getAST = jsep
exports.getAST = getAST

<span class="hljs-keyword">const</span> getRegExp = memoize(pattern =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern))

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParseTree</span> (<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">switch</span> (ast.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
      <span class="hljs-keyword">return</span> (node) =&gt; node[ast.name]
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">return</span> () =&gt; ast.value
    <span class="hljs-keyword">case</span> <span class="hljs-string">'MemberExpression'</span>:
      <span class="hljs-keyword">const</span> memberFn = (node) =&gt; (getParseTree(ast.object)(node) || {})
      <span class="hljs-keyword">const</span> propertyFn = getParseTree(ast.property)

      <span class="hljs-keyword">return</span> ast.computed ? (node) =&gt; memberFn(node)[propertyFn(node)] : (node) =&gt; propertyFn(memberFn(node))
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ArrayExpression'</span>:
      <span class="hljs-keyword">const</span> fnArr = ast.elements.map(getParseTree)

      <span class="hljs-keyword">return</span> (node) =&gt; fnArr.map(fn =&gt; fn(node))
    <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
      <span class="hljs-keyword">const</span> argFns = ast.arguments.map(getParseTree)

      <span class="hljs-keyword">let</span> callee
      <span class="hljs-keyword">let</span> thisRef = _
      <span class="hljs-keyword">switch</span> (ast.callee.type) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Identifier'</span>:
          callee = getParseTree(ast.callee)
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'MemberExpression'</span>:
          callee = getParseTree(ast.callee)
          thisRef = ast.callee.object.value
          <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> <span class="hljs-string">'CallExpression'</span>:
          callee = getParseTree(ast.callee.callee)
      }

      <span class="hljs-keyword">return</span> (node) =&gt; {
        <span class="hljs-keyword">const</span> thisObj = thisRef || node
        <span class="hljs-keyword">let</span> resolved
        <span class="hljs-keyword">if</span> (ast.callee.type === <span class="hljs-string">'CallExpression'</span>) {
          <span class="hljs-keyword">const</span> callArgs = ast[<span class="hljs-string">'callee'</span>].arguments.map(getParseTree)

          resolved = callee(thisObj)
            .apply(thisObj, callArgs.map(fn =&gt; fn(node)))
        } <span class="hljs-keyword">else</span> {
          resolved = callee(thisObj)
        }

        <span class="hljs-keyword">const</span> args = argFns.map(fn =&gt; fn(node))
        <span class="hljs-keyword">const</span> thisBinding = (thisObj === node) &amp;&amp; ast.callee.object ? getParseTree(ast.callee.object)(node) : thisObj

        <span class="hljs-keyword">return</span> isFunction(resolved) ? resolved.apply(thisBinding, args) : <span class="hljs-literal">false</span>
      }

    <span class="hljs-keyword">case</span> <span class="hljs-string">'LogicalExpression'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'BinaryExpression'</span>:
      <span class="hljs-keyword">const</span> left = getParseTree(ast.left)
      <span class="hljs-keyword">const</span> right = getParseTree(ast.right)

      <span class="hljs-keyword">switch</span> (ast.operator) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'=='</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>noinspection EqualityComparisonWithCoercionJS</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">return</span> (node) =&gt; left(node) == right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'==='</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) === right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'!='</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>noinspection EqualityComparisonWithCoercionJS</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">return</span> (node) =&gt; left(node) != right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'!=='</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) !== right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;='</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt;= right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;='</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;= right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'in'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; {
            <span class="hljs-keyword">const</span> resolvedRight = right(node)

            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.isArray(resolvedRight) &amp;&amp; left(node) <span class="hljs-keyword">in</span> resolvedRight
          }
        <span class="hljs-keyword">case</span> <span class="hljs-string">'=~'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; OP_MAP.regx(left(node), right(node))
        <span class="hljs-keyword">case</span> <span class="hljs-string">'=*'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; OP_MAP.glob(left(node), right(node))
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;&amp;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &amp;&amp; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'||'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) || right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) ^ right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'|'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) | right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&amp;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &amp; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&lt;&lt;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &lt;&lt; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;&gt; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'&gt;&gt;&gt;'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) &gt;&gt;&gt; right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) + right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) - right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) * right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) / right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) % right(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'**'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; left(node) ** right(node)
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> stubFalse
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'UnaryExpression'</span>:
      <span class="hljs-keyword">const</span> argEval = getParseTree(ast.argument)

      <span class="hljs-keyword">switch</span> (ast.operator) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'!'</span>:
          <span class="hljs-keyword">return</span> negate(argEval)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; -argEval(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'~'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; ~argEval(node)
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
          <span class="hljs-keyword">return</span> (node) =&gt; +argEval(node)

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> stubFalse
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ThisExpression'</span>:
      <span class="hljs-keyword">return</span> identity
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ConditionalExpression'</span>:
      <span class="hljs-keyword">const</span> test = getParseTree(ast.test)
      <span class="hljs-keyword">const</span> consequent = getParseTree(ast.consequent)
      <span class="hljs-keyword">const</span> alternate = getParseTree(ast.alternate)

      <span class="hljs-keyword">return</span> (node) =&gt; test(node) ? consequent(node) : alternate(node)
  }
}

exports.parseExpr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseExpr</span> (<span class="hljs-params">expr</span>) </span>{
  <span class="hljs-keyword">const</span> ast = getAST(expr)

  <span class="hljs-keyword">return</span> getParseTree(ast)
}

exports.filter = attachSpan(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filter</span> (<span class="hljs-params">nodes, filterExpr</span>) </span>{
  <span class="hljs-keyword">const</span> ast = getAST(filterExpr)
  <span class="hljs-keyword">const</span> filterFn = getParseTree(ast)

  <span class="hljs-keyword">return</span> nodes.filter(filterFn)
}, <span class="hljs-string">'filter'</span>, cto)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMatchingCollNames</span> (<span class="hljs-params">graphNames</span>) </span>{
  <span class="hljs-keyword">return</span> chain(graphNames)
    .map(gg._graph)
    .map(graph =&gt; concat(graph._vertexCollections(), graph._edgeCollections()))
    .flatten()
    .invokeMap(<span class="hljs-string">'name'</span>)
    .uniq()
    .value()
}

exports.getMatchingCollNames = getMatchingCollNames

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonServiceCollections</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> difference(
    db._collections()
      .map(coll =&gt; coll.name())
      .filter(collName =&gt; !collName.startsWith(<span class="hljs-string">'_'</span>)),
    values(SERVICE_COLLECTIONS)
  )
}

exports.getNonServiceCollections = getNonServiceCollections

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeAndSearchPatternFor</span> (<span class="hljs-params">path</span>) </span>{
  <span class="hljs-keyword">const</span> collections = getNonServiceCollections()
  <span class="hljs-keyword">const</span> scopes = getAvailableScopes(collections)

  <span class="hljs-keyword">const</span> scope = find(scopes, scope =&gt; minimatch(path, scope.pathPattern))
  <span class="hljs-keyword">const</span> searchPattern = scope.prefix ? path.substring(scope.prefix.length) : path

  <span class="hljs-keyword">return</span> { scope, searchPattern }
}

exports.getScopeAndSearchPatternFor = getScopeAndSearchPatternFor

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollTypes</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> collTypes = {}
  <span class="hljs-keyword">const</span> nonServiceCollections = getNonServiceCollections()

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> coll <span class="hljs-keyword">of</span> nonServiceCollections) {
    collTypes[coll] = COLL_TYPES_REF[getCollectionType(coll)]
  }

  <span class="hljs-keyword">return</span> collTypes
}

exports.getCollTypes = getCollTypes

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollTypeInitializer</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> collTypes = getCollTypes()

  <span class="hljs-keyword">return</span> aql<span class="hljs-string">`let collTypes = <span class="hljs-subst">${collTypes}</span>`</span>
}

exports.getCollTypeInitializer = getCollTypeInitializer

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeInitializers</span> (<span class="hljs-params">scope, searchPattern</span>) </span>{
  <span class="hljs-keyword">return</span> scope.initializers ? scope.initializers(searchPattern) : aql.literal(<span class="hljs-string">''</span>)
}

exports.getScopeInitializers = getScopeInitializers

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventLogQueryPrefix</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> aql<span class="hljs-string">`
    for v, e, p in 2..<span class="hljs-subst">${Number.MAX_SAFE_INTEGER}</span>
    outbound <span class="hljs-subst">${TRANSIENT_EVENT_SUPERNODE._id}</span>
    <span class="hljs-subst">${commandColl}</span>
  `</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScopeFilters</span> (<span class="hljs-params">scope, searchPattern</span>) </span>{
  <span class="hljs-keyword">return</span> scope.filters ? scope.filters(searchPattern) : {
    filter: aql.literal(<span class="hljs-string">''</span>),
    prune: aql.literal(<span class="hljs-string">'false'</span>)
  }
}

exports.getScopeFilters = getScopeFilters

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTimeBoundFilters</span> (<span class="hljs-params">since, until</span>) </span>{
  <span class="hljs-keyword">const</span> filters = []
  <span class="hljs-keyword">let</span> prune = aql.literal(<span class="hljs-string">'false'</span>)

  <span class="hljs-keyword">if</span> (since) {
    filters.push(aql<span class="hljs-string">`filter v.ctime &gt;= <span class="hljs-subst">${since}</span>`</span>)
  }
  <span class="hljs-keyword">if</span> (until) {
    prune = aql<span class="hljs-string">`v.ctime &gt;= <span class="hljs-subst">${until}</span>`</span>
    filters.push(aql<span class="hljs-string">`filter v.ctime &lt; <span class="hljs-subst">${until}</span>`</span>)
  }

  <span class="hljs-keyword">return</span> { prune, filters }
}

exports.getTimeBoundFilters = getTimeBoundFilters

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDBScope</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    pathPattern: <span class="hljs-string">'/'</span>
  }
}

exports.getDBScope = getDBScope

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGraphScope</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    pathPattern: <span class="hljs-string">'/g/*'</span>,
    prefix: <span class="hljs-string">'/g/'</span>,
    filters: searchPattern =&gt; {
      <span class="hljs-keyword">const</span> graphNames = difference(gg._list(), values(SERVICE_GRAPHS))
      <span class="hljs-keyword">const</span> matches = minimatch.match(graphNames, searchPattern)
      <span class="hljs-keyword">const</span> collNames = getMatchingCollNames(matches)

      <span class="hljs-keyword">return</span> {
        filter: aql<span class="hljs-string">`filter p.vertices[1]['collection'] in <span class="hljs-subst">${collNames}</span>`</span>,
        prune: aql<span class="hljs-string">`length(p.edges) == 1 &amp;&amp; v['collection'] not in <span class="hljs-subst">${collNames}</span>`</span>
      }
    }
  }
}

exports.getGraphScope = getGraphScope

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCollectionScope</span> (<span class="hljs-params">collections</span>) </span>{
  <span class="hljs-keyword">return</span> {
    pathPattern: <span class="hljs-string">'/c/*'</span>,
    prefix: <span class="hljs-string">'/c/'</span>,
    filters: searchPattern =&gt; {
      <span class="hljs-keyword">const</span> matches = minimatch.match(collections, searchPattern)

      <span class="hljs-keyword">return</span> {
        filter: aql<span class="hljs-string">`filter p.vertices[1]['collection'] in <span class="hljs-subst">${matches}</span>`</span>,
        prune: aql<span class="hljs-string">`length(p.edges) == 1 &amp;&amp; v['collection'] not in <span class="hljs-subst">${matches}</span>`</span>
      }
    }
  }
}

exports.getCollectionScope = getCollectionScope

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeGlobScope</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    pathPattern: <span class="hljs-string">'/ng/**'</span>,
    prefix: <span class="hljs-string">'/ng/'</span>,
    filters: searchPattern =&gt; {
      <span class="hljs-keyword">const</span> idPattern = minimatch.makeRe(searchPattern).source

      <span class="hljs-keyword">return</span> {
        filter: aql<span class="hljs-string">`filter p.vertices[2].meta.id =~ <span class="hljs-subst">${idPattern}</span>`</span>,
        prune: aql<span class="hljs-string">`length(p.edges) == 2 &amp;&amp; v.meta.id !~ <span class="hljs-subst">${idPattern}</span>`</span>
      }
    }
  }
}

exports.getNodeGlobScope = getNodeGlobScope

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeBraceScope</span> (<span class="hljs-params">collections</span>) </span>{
  <span class="hljs-keyword">return</span> {
    pathPattern: <span class="hljs-string">'/n/**'</span>,
    prefix: <span class="hljs-string">'/n/'</span>,
    filters: searchPattern =&gt; {
      <span class="hljs-keyword">const</span> collMatches = chain(expand(searchPattern))
        .map(pattern =&gt; pattern.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>])
        .intersection(collections)
        .value()

      <span class="hljs-keyword">return</span> {
        filter: aql<span class="hljs-string">`
            let collName = p.vertices[1]['collection']
            filter collName in <span class="hljs-subst">${collMatches}</span>
            filter p.edges[1].meta.id in idGroups[collName]
          `</span>, <span class="hljs-comment">// See initializers below for idGroups definition.</span>
        prune: aql<span class="hljs-string">`
            length(p.edges) == 2 &amp;&amp; (p.vertices[1]['collection'] not in <span class="hljs-subst">${collMatches}</span>
              || p.edges[1].meta.id not in idGroups[p.vertices[1]['collection']])
          `</span>
      }
    },
    initializers: searchPattern =&gt; {
      <span class="hljs-keyword">const</span> idMatchesWrapper = chain(expand(searchPattern))
      <span class="hljs-keyword">const</span> collMatches = idMatchesWrapper
        .map(pattern =&gt; pattern.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>])
        .intersection(collections)
        .value()
      <span class="hljs-keyword">const</span> idGroups = idMatchesWrapper
        .map(match =&gt; match.split(<span class="hljs-string">'/'</span>))
        .filter(matchPair =&gt; collMatches.includes(matchPair[<span class="hljs-number">0</span>]))
        .transform((groups, matchPair) =&gt; {
          <span class="hljs-keyword">const</span> group = matchPair[<span class="hljs-number">0</span>]
          groups[group] = groups[group] || []
          groups[group].push(matchPair.join(<span class="hljs-string">'/'</span>))
        }, {})
        .value()

      <span class="hljs-keyword">return</span> aql<span class="hljs-string">`let idGroups = <span class="hljs-subst">${idGroups}</span>`</span>
    }
  }
}

exports.getNodeBraceScope = getNodeBraceScope

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAvailableScopes</span> (<span class="hljs-params">collections</span>) </span>{
  <span class="hljs-keyword">return</span> {
    database: getDBScope(),
    graph: getGraphScope(),
    collection: getCollectionScope(collections),
    nodeGlob: getNodeGlobScope(),
    nodeExact: getNodeBraceScope(collections)
  }
}

exports.getLimitClause = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLimitClause</span> (<span class="hljs-params">limit, skip</span>) </span>{
  <span class="hljs-keyword">if</span> (limit) {
    <span class="hljs-keyword">if</span> (skip) {
      <span class="hljs-keyword">return</span> aql<span class="hljs-string">`limit <span class="hljs-subst">${skip}</span>, <span class="hljs-subst">${limit}</span>`</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> aql<span class="hljs-string">`limit <span class="hljs-subst">${limit}</span>`</span>
    }
  }

  <span class="hljs-keyword">return</span> aql.literal(<span class="hljs-string">''</span>)
}

exports.getEventLogQueryInitializer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEventLogQueryInitializer</span> (<span class="hljs-params">path, since, until</span>) </span>{
  <span class="hljs-keyword">const</span> { scope, searchPattern } = getScopeAndSearchPatternFor(path)
  <span class="hljs-keyword">const</span> scopeFilters = getScopeFilters(scope, searchPattern)
  <span class="hljs-keyword">const</span> timeBoundFilters = getTimeBoundFilters(since, until)
  <span class="hljs-keyword">const</span> pruneFilters = aql.join([scopeFilters.prune, timeBoundFilters.prune], <span class="hljs-string">' || '</span>)
  <span class="hljs-keyword">const</span> pruneClause = aql.join([aql.literal(<span class="hljs-string">'prune'</span>), pruneFilters], <span class="hljs-string">' '</span>)

  <span class="hljs-keyword">const</span> queryParts = [
    getCollTypeInitializer(),
    getScopeInitializers(scope, searchPattern),
    getEventLogQueryPrefix(),
    pruneClause,
    scopeFilters.filter
  ]

  timeBoundFilters.filters.forEach(filter =&gt; queryParts.push(filter))

  <span class="hljs-keyword">return</span> queryParts
}

exports.getSort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSort</span> (<span class="hljs-params">sortKey</span>) </span>{
  <span class="hljs-keyword">return</span> SORT_TYPES[sortKey.toUpperCase()]
}</div></div></div></div></body></html>